
@subheading gnutls_protocol_get_version
@anchor{gnutls_protocol_get_version}
@deftypefun {gnutls_protocol_t} {gnutls_protocol_get_version} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the version of the currently used protocol. 
@end deftypefun

@subheading gnutls_transport_set_lowat
@anchor{gnutls_transport_set_lowat}
@deftypefun {void} {gnutls_transport_set_lowat} (gnutls_session_t @var{session}, int @var{num})
@var{session}: is a @code{gnutls_session_t} structure.

@var{num}: is the low water value.

Used to set the lowat value in order for select to check
if there are pending data to socket buffer. Used only   
if you have changed the default low water value (default is 1).
Normally you will not need that function. 
This function is only useful if using berkeley style sockets.
Otherwise it must be called and set lowat to zero.
@end deftypefun

@subheading gnutls_transport_set_ptr
@anchor{gnutls_transport_set_ptr}
@deftypefun {void} {gnutls_transport_set_ptr} (gnutls_session_t @var{session}, gnutls_transport_ptr_t @var{ptr})
@var{session}: is a @code{gnutls_session_t} structure.

@var{ptr}: is the value.

Used to set the first argument of the transport function (like PUSH and
PULL). In berkeley style sockets this function will set the connection
handle.
@end deftypefun

@subheading gnutls_transport_set_ptr2
@anchor{gnutls_transport_set_ptr2}
@deftypefun {void} {gnutls_transport_set_ptr2} (gnutls_session_t @var{session}, gnutls_transport_ptr_t @var{recv_ptr}, gnutls_transport_ptr_t @var{send_ptr})
@var{session}: is a @code{gnutls_session_t} structure.

@var{recv_ptr}: is the value for the pull function

@var{send_ptr}: is the value for the push function

Used to set the first argument of the transport function (like PUSH and
PULL). In berkeley style sockets this function will set the connection
handle. With this function you can use two different pointers for
receiving and sending.
@end deftypefun

@subheading gnutls_transport_get_ptr
@anchor{gnutls_transport_get_ptr}
@deftypefun {gnutls_transport_ptr_t} {gnutls_transport_get_ptr} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Used to get the first argument of the transport function (like PUSH and
PULL). This must have been set using @code{gnutls_transport_set_ptr()}.
@end deftypefun

@subheading gnutls_transport_get_ptr2
@anchor{gnutls_transport_get_ptr2}
@deftypefun {void} {gnutls_transport_get_ptr2} (gnutls_session_t @var{session}, gnutls_transport_ptr_t * @var{recv_ptr}, gnutls_transport_ptr_t * @var{send_ptr})
@var{session}: is a @code{gnutls_session_t} structure.

@var{recv_ptr}: will hold the value for the pull function

@var{send_ptr}: will hold the value for the push function

Used to get the arguments of the transport functions (like PUSH and
PULL). These should have been set using @code{gnutls_transport_set_ptr2()}.
@end deftypefun

@subheading gnutls_bye
@anchor{gnutls_bye}
@deftypefun {int} {gnutls_bye} (gnutls_session_t @var{session}, gnutls_close_request_t @var{how})
@var{session}: is a @code{gnutls_session_t} structure.

@var{how}: is an integer

Terminates the current TLS/SSL connection. The connection should
have been initiated using @code{gnutls_handshake()}.
@code{how} should be one of GNUTLS_SHUT_RDWR, GNUTLS_SHUT_WR.

In case of GNUTLS_SHUT_RDWR then the TLS connection gets terminated and
further receives and sends will be disallowed. If the return
value is zero you may continue using the connection.
GNUTLS_SHUT_RDWR actually sends an alert containing a close request
and waits for the peer to reply with the same message.

In case of GNUTLS_SHUT_WR then the TLS connection gets terminated and
further sends will be disallowed. In order to reuse the connection
you should wait for an EOF from the peer.
GNUTLS_SHUT_WR sends an alert containing a close request.

Note that not all implementations will properly terminate a TLS connection.
Some of them, usually for performance reasons, will terminate only the 
underlying transport layer, thus causing a transmission error to the peer.
This error cannot be distinguished from a malicious party prematurely terminating
the session, thus this behavior is not recommended.

This function may also return GNUTLS_E_AGAIN or GNUTLS_E_INTERRUPTED; cf.
@code{gnutls_record_get_direction()}.
@end deftypefun

@subheading gnutls_record_send
@anchor{gnutls_record_send}
@deftypefun {ssize_t} {gnutls_record_send} (gnutls_session_t @var{session}, const void * @var{data}, size_t @var{sizeofdata})
@var{session}: is a @code{gnutls_session_t} structure.

@var{data}: contains the data to send

@var{sizeofdata}: is the length of the data

This function has the similar semantics with @code{send()}. The only
difference is that is accepts a GNUTLS session, and uses different
error codes.

Note that if the send buffer is full, @code{send()} will block this
function.  See the @code{send()} documentation for full information.  You
can replace the default push function by using
@code{gnutls_transport_set_ptr2()} with a call to @code{send()} with a
MSG_DONTWAIT flag if blocking is a problem.

If the EINTR is returned by the internal push function (the
default is @code{send()}@} then @code{GNUTLS_E_INTERRUPTED} will be returned. If
@code{GNUTLS_E_INTERRUPTED} or @code{GNUTLS_E_AGAIN} is returned, you must
call this function again, with the same parameters; alternatively
you could provide a @code{NULL} pointer for data, and 0 for
size. cf. @code{gnutls_record_get_direction()}.

Returns the number of bytes sent, or a negative error code. The
number of bytes sent might be less than @code{sizeofdata}. The maximum
number of bytes this function can send in a single call depends on
the negotiated maximum record size.
@end deftypefun

@subheading gnutls_record_recv
@anchor{gnutls_record_recv}
@deftypefun {ssize_t} {gnutls_record_recv} (gnutls_session_t @var{session}, void * @var{data}, size_t @var{sizeofdata})
@var{session}: is a @code{gnutls_session_t} structure.

@var{data}: the buffer that the data will be read into

@var{sizeofdata}: the number of requested bytes

This function has the similar semantics with @code{recv()}. The only
difference is that is accepts a GNUTLS session, and uses different
error codes.

In the special case that a server requests a renegotiation, the
client may receive an error code of GNUTLS_E_REHANDSHAKE.  This
message may be simply ignored, replied with an alert containing
NO_RENEGOTIATION, or replied with a new handshake, depending on
the client's will.

If EINTR is returned by the internal push function (the default is
@code{code}@{@code{recv()}@}) then GNUTLS_E_INTERRUPTED will be returned. If
GNUTLS_E_INTERRUPTED or GNUTLS_E_AGAIN is returned, you must call
this function again, with the same parameters; alternatively you
could provide a NULL pointer for data, and 0 for
size. cf. @code{code}@{@code{gnutls_record_get_direction()}@}.

A server may also receive GNUTLS_E_REHANDSHAKE when a client has
initiated a handshake. In that case the server can only initiate a
handshake or terminate the connection.

Returns the number of bytes received and zero on EOF.  A negative
error code is returned in case of an error.  The number of bytes
received might be less than @code{code}@{count@}.
@end deftypefun

@subheading gnutls_record_get_max_size
@anchor{gnutls_record_get_max_size}
@deftypefun {size_t} {gnutls_record_get_max_size} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function returns the maximum record packet size in this connection.
The maximum record size is negotiated by the client after the
first handshake message.
@end deftypefun

@subheading gnutls_record_set_max_size
@anchor{gnutls_record_set_max_size}
@deftypefun {ssize_t} {gnutls_record_set_max_size} (gnutls_session_t @var{session}, size_t @var{size})
@var{session}: is a @code{gnutls_session_t} structure.

@var{size}: is the new size

This function sets the maximum record packet size in this connection.
This property can only be set to clients. The server may
choose not to accept the requested size.

Acceptable values are 512(=2^9), 1024(=2^10), 2048(=2^11) and 4096(=2^12).
Returns 0 on success. The requested record size does
get in effect immediately only while sending data. The receive
part will take effect after a successful handshake.

This function uses a TLS extension called 'max record size'.
Not all TLS implementations use or even understand this extension.
@end deftypefun

@subheading gnutls_record_check_pending
@anchor{gnutls_record_check_pending}
@deftypefun {size_t} {gnutls_record_check_pending} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function checks if there are any data to receive
in the gnutls buffers. Returns the size of that data or 0.
Notice that you may also use @code{select()} to check for data in
a TCP connection, instead of this function.
(gnutls leaves some data in the tcp buffer in order for select
to work).
@end deftypefun

@subheading gnutls_rehandshake
@anchor{gnutls_rehandshake}
@deftypefun {int} {gnutls_rehandshake} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function will renegotiate security parameters with the
client. This should only be called in case of a server.

This message informs the peer that we want to renegotiate
parameters (perform a handshake).

If this function succeeds (returns 0), you must call
the @code{gnutls_handshake()} function in order to negotiate
the new parameters.

If the client does not wish to renegotiate parameters he
will should with an alert message, thus the return code will be
GNUTLS_E_WARNING_ALERT_RECEIVED and the alert will be
GNUTLS_A_NO_RENEGOTIATION. A client may also choose to ignore
this message.
@end deftypefun

@subheading gnutls_handshake
@anchor{gnutls_handshake}
@deftypefun {int} {gnutls_handshake} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function does the handshake of the TLS/SSL protocol,
and initializes the TLS connection. 

This function will fail if any problem is encountered,
and will return a negative error code. In case of a client,
if the client has asked to resume a session, but the server couldn't, 
then a full handshake will be performed.

The non-fatal errors such as GNUTLS_E_AGAIN and GNUTLS_E_INTERRUPTED
interrupt the handshake procedure, which should be later be resumed.
Call this function again, until it returns 0; cf.
@code{gnutls_record_get_direction()} and @code{gnutls_error_is_fatal()}.

If this function is called by a server after a rehandshake request then
GNUTLS_E_GOT_APPLICATION_DATA or GNUTLS_E_WARNING_ALERT_RECEIVED 
may be returned. Note that these are non fatal errors, only in the
specific case of a rehandshake. Their meaning is that the client
rejected the rehandshake request.
@end deftypefun

@subheading gnutls_handshake_set_max_packet_length
@anchor{gnutls_handshake_set_max_packet_length}
@deftypefun {void} {gnutls_handshake_set_max_packet_length} (gnutls_session_t @var{session}, size_t @var{max})
@var{session}: is a @code{gnutls_session_t} structure.

@var{max}: is the maximum number.

This function will set the maximum size of a handshake message.
Handshake messages over this size are rejected.
The default value is 16kb which is large enough. Set this to 0 if you do not want
to set an upper limit.
@end deftypefun

@subheading gnutls_handshake_get_last_in
@anchor{gnutls_handshake_get_last_in}
@deftypefun {gnutls_handshake_description_t} {gnutls_handshake_get_last_in} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the last handshake message received. This function is only useful
to check where the last performed handshake failed. If the previous handshake
succeed or was not performed at all then no meaningful value will be returned.

Check gnutls.h for the available handshake descriptions.
@end deftypefun

@subheading gnutls_handshake_get_last_out
@anchor{gnutls_handshake_get_last_out}
@deftypefun {gnutls_handshake_description_t} {gnutls_handshake_get_last_out} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the last handshake message sent. This function is only useful
to check where the last performed handshake failed. If the previous handshake
succeed or was not performed at all then no meaningful value will be returned.

Check gnutls.h for the available handshake descriptions.
@end deftypefun

@subheading gnutls_error_is_fatal
@anchor{gnutls_error_is_fatal}
@deftypefun {int} {gnutls_error_is_fatal} (int @var{error})
@var{error}: is an error returned by a gnutls function. Error should be a negative value.

If a function returns a negative value you may feed that value
to this function to see if it is fatal. Returns 1 for a fatal 
error 0 otherwise. However you may want to check the
error code manually, since some non-fatal errors to the protocol
may be fatal for you (your program).

This is only useful if you are dealing with errors from the
record layer or the handshake layer.
@end deftypefun

@subheading gnutls_perror
@anchor{gnutls_perror}
@deftypefun {void} {gnutls_perror} (int @var{error})
@var{error}: is an error returned by a gnutls function. Error is always a negative value.

This function is like @code{perror()}. The only difference is that it accepts an 
error number returned by a gnutls function.
@end deftypefun

@subheading gnutls_strerror
@anchor{gnutls_strerror}
@deftypefun {const char *} {gnutls_strerror} (int @var{error})
@var{error}: is an error returned by a gnutls function. Error is always a negative value.

This function is similar to @code{strerror()}. Differences: it accepts an error
number returned by a gnutls function; In case of an unknown error
a descriptive string is sent instead of NULL.
@end deftypefun

@subheading gnutls_mac_get_name
@anchor{gnutls_mac_get_name}
@deftypefun {const char *} {gnutls_mac_get_name} (gnutls_mac_algorithm_t @var{algorithm})
@var{algorithm}: is a MAC algorithm

Returns a string that contains the name
of the specified MAC algorithm or NULL.
@end deftypefun

@subheading gnutls_compression_get_name
@anchor{gnutls_compression_get_name}
@deftypefun {const char *} {gnutls_compression_get_name} (gnutls_compression_method_t @var{algorithm})
@var{algorithm}: is a Compression algorithm

Returns a pointer to a string that contains the name
of the specified compression algorithm or NULL.
@end deftypefun

@subheading gnutls_cipher_get_key_size
@anchor{gnutls_cipher_get_key_size}
@deftypefun {size_t} {gnutls_cipher_get_key_size} (gnutls_cipher_algorithm_t @var{algorithm})
@var{algorithm}: is an encryption algorithm

Returns the length (in bytes) of the given cipher's key size.
Returns 0 if the given cipher is invalid.
@end deftypefun

@subheading gnutls_cipher_get_name
@anchor{gnutls_cipher_get_name}
@deftypefun {const char *} {gnutls_cipher_get_name} (gnutls_cipher_algorithm_t @var{algorithm})
@var{algorithm}: is an encryption algorithm

Returns a pointer to a string that contains the name
of the specified cipher or NULL.
@end deftypefun

@subheading gnutls_kx_get_name
@anchor{gnutls_kx_get_name}
@deftypefun {const char *} {gnutls_kx_get_name} (gnutls_kx_algorithm_t @var{algorithm})
@var{algorithm}: is a key exchange algorithm

Returns a pointer to a string that contains the name 
of the specified key exchange algorithm or NULL.
@end deftypefun

@subheading gnutls_protocol_get_name
@anchor{gnutls_protocol_get_name}
@deftypefun {const char *} {gnutls_protocol_get_name} (gnutls_protocol_t @var{version})
@var{version}: is a (gnutls) version number

Returns a string that contains the name
of the specified TLS version or NULL.
@end deftypefun

@subheading gnutls_cipher_suite_get_name
@anchor{gnutls_cipher_suite_get_name}
@deftypefun {const char *} {gnutls_cipher_suite_get_name} (gnutls_kx_algorithm_t          @var{kx_algorithm}, gnutls_cipher_algorithm_t          @var{cipher_algorithm}, gnutls_mac_algorithm_t @var{mac_algorithm})
@var{kx_algorithm}: is a Key exchange algorithm

@var{cipher_algorithm}: is a cipher algorithm

@var{mac_algorithm}: is a MAC algorithm

Returns a string that contains the name of a TLS
cipher suite, specified by the given algorithms, or NULL.

Note that the full cipher suite name must be prepended
by TLS or SSL depending of the protocol in use.
@end deftypefun

@subheading gnutls_certificate_type_get_name
@anchor{gnutls_certificate_type_get_name}
@deftypefun {const char *} {gnutls_certificate_type_get_name} (gnutls_certificate_type_t @var{type})
@var{type}: is a certificate type

Returns a string (or NULL) that contains the name
of the specified certificate type.
@end deftypefun

@subheading gnutls_sign_algorithm_get_name
@anchor{gnutls_sign_algorithm_get_name}
@deftypefun {const char *} {gnutls_sign_algorithm_get_name} (gnutls_sign_algorithm_t @var{sign})
Returns a string that contains the name
of the specified sign algorithm or NULL.
@end deftypefun

@subheading gnutls_pk_algorithm_get_name
@anchor{gnutls_pk_algorithm_get_name}
@deftypefun {const char *} {gnutls_pk_algorithm_get_name} (gnutls_pk_algorithm_t @var{algorithm})
@var{algorithm}: is a pk algorithm

Returns a string that contains the name
of the specified public key algorithm or NULL.
@end deftypefun

@subheading gnutls_cipher_set_priority
@anchor{gnutls_cipher_set_priority}
@deftypefun {int} {gnutls_cipher_set_priority} (gnutls_session_t @var{session}, const int * @var{list})
@var{session}: is a @code{gnutls_session_t} structure.

@var{list}: is a 0 terminated list of gnutls_cipher_algorithm_t elements.

Sets the priority on the ciphers supported by gnutls.
Priority is higher for ciphers specified before others.
After specifying the ciphers you want, you must append a 0.
Note that the priority is set on the client. The server does
not use the algorithm's priority except for disabling
algorithms that were not specified.

Returns 0 on success.
@end deftypefun

@subheading gnutls_kx_set_priority
@anchor{gnutls_kx_set_priority}
@deftypefun {int} {gnutls_kx_set_priority} (gnutls_session_t @var{session}, const int * @var{list})
@var{session}: is a @code{gnutls_session_t} structure.

@var{list}: is a 0 terminated list of gnutls_kx_algorithm_t elements.

Sets the priority on the key exchange algorithms supported by gnutls.
Priority is higher for algorithms specified before others.
After specifying the algorithms you want, you must append a 0.
Note that the priority is set on the client. The server does
not use the algorithm's priority except for disabling
algorithms that were not specified.

Returns 0 on success.
@end deftypefun

@subheading gnutls_mac_set_priority
@anchor{gnutls_mac_set_priority}
@deftypefun {int} {gnutls_mac_set_priority} (gnutls_session_t @var{session}, const int * @var{list})
@var{session}: is a @code{gnutls_session_t} structure.

@var{list}: is a 0 terminated list of gnutls_mac_algorithm_t elements.

Sets the priority on the mac algorithms supported by gnutls.
Priority is higher for algorithms specified before others.
After specifying the algorithms you want, you must append a 0.
Note that the priority is set on the client. The server does
not use the algorithm's priority except for disabling
algorithms that were not specified.

Returns 0 on success.
@end deftypefun

@subheading gnutls_compression_set_priority
@anchor{gnutls_compression_set_priority}
@deftypefun {int} {gnutls_compression_set_priority} (gnutls_session_t @var{session}, const int * @var{list})
@var{session}: is a @code{gnutls_session_t} structure.

@var{list}: is a 0 terminated list of gnutls_compression_method_t elements.

Sets the priority on the compression algorithms supported by gnutls.
Priority is higher for algorithms specified before others.
After specifying the algorithms you want, you must append a 0.
Note that the priority is set on the client. The server does
not use the algorithm's priority except for disabling
algorithms that were not specified.

TLS 1.0 does not define any compression algorithms except
NULL. Other compression algorithms are to be considered
as gnutls extensions.

Returns 0 on success.
@end deftypefun

@subheading gnutls_protocol_set_priority
@anchor{gnutls_protocol_set_priority}
@deftypefun {int} {gnutls_protocol_set_priority} (gnutls_session_t @var{session}, const int * @var{list})
@var{session}: is a @code{gnutls_session_t} structure.

@var{list}: is a 0 terminated list of gnutls_protocol_t elements.

Sets the priority on the protocol versions supported by gnutls.
This function actually enables or disables protocols. Newer protocol
versions always have highest priority.

Returns 0 on success.
@end deftypefun

@subheading gnutls_certificate_type_set_priority
@anchor{gnutls_certificate_type_set_priority}
@deftypefun {int} {gnutls_certificate_type_set_priority} (gnutls_session_t @var{session}, const int * @var{list})
@var{session}: is a @code{gnutls_session_t} structure.

@var{list}: is a 0 terminated list of gnutls_certificate_type_t elements.

Sets the priority on the certificate types supported by gnutls.
Priority is higher for types specified before others.
After specifying the types you want, you must append a 0.
Note that the certificate type priority is set on the client. 
The server does not use the cert type priority except for disabling
types that were not specified.

Returns 0 on success.
@end deftypefun

@subheading gnutls_set_default_priority
@anchor{gnutls_set_default_priority}
@deftypefun {int} {gnutls_set_default_priority} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Sets some default priority on the ciphers, key exchange methods, macs
and compression methods. This is to avoid using the gnutls_*@code{_priority()} functions, if
these defaults are ok. You may override any of the following priorities by calling
the appropriate functions.

The order is TLS1, SSL3 for protocols.
RSA, DHE_DSS, DHE_RSA for key exchange 
algorithms. SHA, MD5 and RIPEMD160 for MAC algorithms.
AES_128_CBC, 3DES_CBC, 
and ARCFOUR_128 for ciphers.

Returns 0 on success.
@end deftypefun

@subheading gnutls_set_default_export_priority
@anchor{gnutls_set_default_export_priority}
@deftypefun {int} {gnutls_set_default_export_priority} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Sets some default priority on the ciphers, key exchange methods, macs
and compression methods. This is to avoid using the gnutls_*@code{_priority()} functions, if
these defaults are ok. This function also includes weak algorithms.
The order is TLS1, SSL3 for protocols,  RSA, DHE_DSS, 
DHE_RSA, RSA_EXPORT for key exchange algorithms.
SHA, MD5, RIPEMD160 for MAC algorithms,
AES_256_CBC, AES_128_CBC, 
and 3DES_CBC, ARCFOUR_128, ARCFOUR_40 for ciphers.

Returns 0 on success.
@end deftypefun

@subheading gnutls_session_get_data
@anchor{gnutls_session_get_data}
@deftypefun {int} {gnutls_session_get_data} (gnutls_session_t @var{session}, void * @var{session_data}, size_t * @var{session_data_size})
@var{session}: is a @code{gnutls_session_t} structure.

@var{session_data}: is a pointer to space to hold the session.

@var{session_data_size}: is the session_data's size, or it will be set by the function.

Returns all session parameters, in order to support resuming.
The client should call this, and keep the returned session, if he wants to
resume that current version later by calling @code{gnutls_session_set_data()}
This function must be called after a successful handshake.

Resuming sessions is really useful and speedups connections after a succesful one.
@end deftypefun

@subheading gnutls_session_get_data2
@anchor{gnutls_session_get_data2}
@deftypefun {int} {gnutls_session_get_data2} (gnutls_session_t @var{session}, gnutls_datum * @var{data})
@var{session}: is a @code{gnutls_session_t} structure.

Returns all session parameters, in order to support resuming.
The client should call this, and keep the returned session, if he wants to
resume that current version later by calling @code{gnutls_session_set_data()}
This function must be called after a successful handshake. The returned
datum must be freed with @code{gnutls_free()}.

Resuming sessions is really useful and speedups connections after a succesful one.
@end deftypefun

@subheading gnutls_session_get_id
@anchor{gnutls_session_get_id}
@deftypefun {int} {gnutls_session_get_id} (gnutls_session_t @var{session}, void * @var{session_id}, size_t * @var{session_id_size})
@var{session}: is a @code{gnutls_session_t} structure.

@var{session_id}: is a pointer to space to hold the session id.

@var{session_id_size}: is the session id's size, or it will be set by the function.

Returns the current session id. This can be used if you want to check if
the next session you tried to resume was actually resumed.
This is because resumed sessions have the same sessionID with the 
original session.

Session id is some data set by the server, that identify the current session. 
In TLS 1.0 and SSL 3.0 session id is always less than 32 bytes.

Returns zero on success.
@end deftypefun

@subheading gnutls_session_set_data
@anchor{gnutls_session_set_data}
@deftypefun {int} {gnutls_session_set_data} (gnutls_session_t @var{session}, const void * @var{session_data}, size_t @var{session_data_size})
@var{session}: is a @code{gnutls_session_t} structure.

@var{session_data}: is a pointer to space to hold the session.

@var{session_data_size}: is the session's size

Sets all session parameters, in order to resume a previously established
session. The session data given must be the one returned by @code{gnutls_session_get_data()}.
This function should be called before @code{gnutls_handshake()}.

Keep in mind that session resuming is advisory. The server may
choose not to resume the session, thus a full handshake will be
performed.

Returns a negative value on error.
@end deftypefun

@subheading gnutls_db_set_retrieve_function
@anchor{gnutls_db_set_retrieve_function}
@deftypefun {void} {gnutls_db_set_retrieve_function} (gnutls_session_t @var{session}, gnutls_db_retr_func @var{retr_func})
@var{session}: is a @code{gnutls_session_t} structure.

@var{retr_func}: is the function.

Sets the function that will be used to retrieve data from the resumed
sessions database. This function must return a gnutls_datum_t containing the
data on success, or a gnutls_datum_t containing null and 0 on failure.

The datum's data must be allocated using the function
@code{gnutls_malloc()}.

The first argument to @code{retr_func()} will be null unless @code{gnutls_db_set_ptr()} 
has been called.
@end deftypefun

@subheading gnutls_db_set_remove_function
@anchor{gnutls_db_set_remove_function}
@deftypefun {void} {gnutls_db_set_remove_function} (gnutls_session_t @var{session}, gnutls_db_remove_func @var{rem_func})
@var{session}: is a @code{gnutls_session_t} structure.

@var{rem_func}: is the function.

Sets the function that will be used to remove data from the resumed
sessions database. This function must return 0 on success.

The first argument to @code{rem_func()} will be null unless @code{gnutls_db_set_ptr()} 
has been called.
@end deftypefun

@subheading gnutls_db_set_store_function
@anchor{gnutls_db_set_store_function}
@deftypefun {void} {gnutls_db_set_store_function} (gnutls_session_t @var{session}, gnutls_db_store_func @var{store_func})
@var{session}: is a @code{gnutls_session_t} structure.

@var{store_func}: is the function

Sets the function that will be used to store data from the resumed
sessions database. This function must remove 0 on success. 

The first argument to @code{store_func()} will be null unless @code{gnutls_db_set_ptr()} 
has been called.
@end deftypefun

@subheading gnutls_db_set_ptr
@anchor{gnutls_db_set_ptr}
@deftypefun {void} {gnutls_db_set_ptr} (gnutls_session_t @var{session}, void * @var{ptr})
@var{session}: is a @code{gnutls_session_t} structure.

@var{ptr}: is the pointer

Sets the pointer that will be provided to db store, retrieve and delete functions, as
the first argument. 
@end deftypefun

@subheading gnutls_db_get_ptr
@anchor{gnutls_db_get_ptr}
@deftypefun {void *} {gnutls_db_get_ptr} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the pointer that will be sent to db store, retrieve and delete functions, as
the first argument. 
@end deftypefun

@subheading gnutls_db_set_cache_expiration
@anchor{gnutls_db_set_cache_expiration}
@deftypefun {void} {gnutls_db_set_cache_expiration} (gnutls_session_t @var{session}, int @var{seconds})
@var{session}: is a @code{gnutls_session_t} structure.

@var{seconds}: is the number of seconds.

Sets the expiration time for resumed sessions. The default is 3600 (one hour)
at the time writing this.
@end deftypefun

@subheading gnutls_db_check_entry
@anchor{gnutls_db_check_entry}
@deftypefun {int} {gnutls_db_check_entry} (gnutls_session_t @var{session}, gnutls_datum_t @var{session_entry})
@var{session}: is a @code{gnutls_session_t} structure.

@var{session_entry}: is the session data (not key)

This function returns GNUTLS_E_EXPIRED, if the database entry
has expired or 0 otherwise. This function is to be used when
you want to clear unnesessary session which occupy space in your
backend.
@end deftypefun

@subheading gnutls_db_remove_session
@anchor{gnutls_db_remove_session}
@deftypefun {void} {gnutls_db_remove_session} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function will remove the current session data from the session
database. This will prevent future handshakes reusing these session
data. This function should be called if a session was terminated
abnormally, and before @code{gnutls_deinit()} is called.

Normally @code{gnutls_deinit()} will remove abnormally terminated sessions.
@end deftypefun

@subheading gnutls_pem_base64_encode
@anchor{gnutls_pem_base64_encode}
@deftypefun {int} {gnutls_pem_base64_encode} (const char * @var{msg}, const gnutls_datum_t * @var{data}, char * @var{result}, size_t * @var{result_size})
@var{msg}: is a message to be put in the header

@var{data}: contain the raw data

@var{result}: the place where base64 data will be copied

@var{result_size}: holds the size of the result

This function will convert the given data to printable data, using the base64 
encoding. This is the encoding used in PEM messages. If the provided
buffer is not long enough GNUTLS_E_SHORT_MEMORY_BUFFER is returned.

The output string will be null terminated, although the size will not include
the terminating null.
@end deftypefun

@subheading gnutls_pem_base64_encode_alloc
@anchor{gnutls_pem_base64_encode_alloc}
@deftypefun {int} {gnutls_pem_base64_encode_alloc} (const char * @var{msg}, const gnutls_datum_t * @var{data}, gnutls_datum_t * @var{result})
@var{msg}: is a message to be put in the encoded header

@var{data}: contains the raw data

@var{result}: will hold the newly allocated encoded data

This function will convert the given data to printable data, using the base64 
encoding. This is the encoding used in PEM messages. This function will
allocate the required memory to hold the encoded data.

You should use @code{gnutls_free()} to free the returned data.
@end deftypefun

@subheading gnutls_pem_base64_decode
@anchor{gnutls_pem_base64_decode}
@deftypefun {int} {gnutls_pem_base64_decode} (const char * @var{header}, const gnutls_datum_t * @var{b64_data}, unsigned char * @var{result}, size_t * @var{result_size})
@var{header}: A null terminated string with the PEM header (eg. CERTIFICATE)

@var{b64_data}: contain the encoded data

@var{result}: the place where decoded data will be copied

@var{result_size}: holds the size of the result

This function will decode the given encoded data. If the header given
is non null this function will search for "-----BEGIN header" and decode
only this part. Otherwise it will decode the first PEM packet found.

Returns GNUTLS_E_SHORT_MEMORY_BUFFER if the buffer given is not long enough,
or 0 on success.
@end deftypefun

@subheading gnutls_pem_base64_decode_alloc
@anchor{gnutls_pem_base64_decode_alloc}
@deftypefun {int} {gnutls_pem_base64_decode_alloc} (const char * @var{header}, const gnutls_datum_t * @var{b64_data}, gnutls_datum_t * @var{result})
@var{header}: The PEM header (eg. CERTIFICATE)

@var{b64_data}: contains the encoded data

@var{result}: the place where decoded data lie

This function will decode the given encoded data. The decoded data
will be allocated, and stored into result.
If the header given is non null this function will search for 
"-----BEGIN header" and decode only this part. Otherwise it will decode the 
first PEM packet found.

You should use @code{gnutls_free()} to free the returned data.
@end deftypefun

@subheading gnutls_credentials_clear
@anchor{gnutls_credentials_clear}
@deftypefun {void} {gnutls_credentials_clear} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Clears all the credentials previously set in this session.
@end deftypefun

@subheading gnutls_credentials_set
@anchor{gnutls_credentials_set}
@deftypefun {int} {gnutls_credentials_set} (gnutls_session_t @var{session}, gnutls_credentials_type_t @var{type}, void * @var{cred})
@var{session}: is a @code{gnutls_session_t} structure.

@var{type}: is the type of the credentials

@var{cred}: is a pointer to a structure.

Sets the needed credentials for the specified type.
Eg username, password - or public and private keys etc.  
The (void* cred) parameter is a structure that depends on the
specified type and on the current session (client or server).
[ In order to minimize memory usage, and share credentials between 
several threads gnutls keeps a pointer to cred, and not the whole cred
structure. Thus you will have to keep the structure allocated until   
you call @code{gnutls_deinit()}. ]

For GNUTLS_CRD_ANON cred should be gnutls_anon_client_credentials_t in case of a client.
In case of a server it should be gnutls_anon_server_credentials_t.

For GNUTLS_CRD_SRP cred should be gnutls_srp_client_credentials_t
in case of a client, and gnutls_srp_server_credentials_t, in case
of a server.

For GNUTLS_CRD_CERTIFICATE cred should be gnutls_certificate_credentials_t.
@end deftypefun

@subheading gnutls_auth_get_type
@anchor{gnutls_auth_get_type}
@deftypefun {gnutls_credentials_type_t} {gnutls_auth_get_type} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns type of credentials for the current authentication schema.
The returned information is to be used to distinguish the function used
to access authentication data.

Eg. for CERTIFICATE ciphersuites (key exchange algorithms: KX_RSA, KX_DHE_RSA),
the same function are to be used to access the authentication data.
@end deftypefun

@subheading gnutls_auth_server_get_type
@anchor{gnutls_auth_server_get_type}
@deftypefun {gnutls_credentials_type_t} {gnutls_auth_server_get_type} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the type of credentials that were used for server authentication.
The returned information is to be used to distinguish the function used
to access authentication data.
@end deftypefun

@subheading gnutls_auth_client_get_type
@anchor{gnutls_auth_client_get_type}
@deftypefun {gnutls_credentials_type_t} {gnutls_auth_client_get_type} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the type of credentials that were used for client authentication.
The returned information is to be used to distinguish the function used
to access authentication data.
@end deftypefun

@subheading gnutls_certificate_free_keys
@anchor{gnutls_certificate_free_keys}
@deftypefun {void} {gnutls_certificate_free_keys} (gnutls_certificate_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_certificate_credentials_t} structure.

This function will delete all the keys and the certificates associated
with the given credentials. This function must not be called when a
TLS negotiation that uses the credentials is in progress.
@end deftypefun

@subheading gnutls_certificate_free_cas
@anchor{gnutls_certificate_free_cas}
@deftypefun {void} {gnutls_certificate_free_cas} (gnutls_certificate_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_certificate_credentials_t} structure.

This function will delete all the CAs associated
with the given credentials. Servers that do not use
@code{gnutls_certificate_verify_peers2()} may call this to
save some memory.
@end deftypefun

@subheading gnutls_certificate_free_ca_names
@anchor{gnutls_certificate_free_ca_names}
@deftypefun {void} {gnutls_certificate_free_ca_names} (gnutls_certificate_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_certificate_credentials_t} structure.

This function will delete all the CA name in the
given credentials. Clients may call this to save some memory
since in client side the CA names are not used.

CA names are used by servers to advertize the CAs they
support to clients.
@end deftypefun

@subheading gnutls_certificate_free_credentials
@anchor{gnutls_certificate_free_credentials}
@deftypefun {void} {gnutls_certificate_free_credentials} (gnutls_certificate_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_certificate_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it.

This function does not free any temporary parameters associated
with this structure (ie RSA and DH parameters are not freed by
this function).
@end deftypefun

@subheading gnutls_certificate_allocate_credentials
@anchor{gnutls_certificate_allocate_credentials}
@deftypefun {int} {gnutls_certificate_allocate_credentials} (gnutls_certificate_credentials_t *       @var{res})
@var{res}: is a pointer to an @code{gnutls_certificate_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

Returns 0 on success.
@end deftypefun

@subheading gnutls_certificate_server_set_request
@anchor{gnutls_certificate_server_set_request}
@deftypefun {void} {gnutls_certificate_server_set_request} (gnutls_session_t @var{session}, gnutls_certificate_request_t @var{req})
@var{session}: is an @code{gnutls_session_t} structure.

@var{req}: is one of GNUTLS_CERT_REQUEST, GNUTLS_CERT_REQUIRE

This function specifies if we (in case of a server) are going
to send a certificate request message to the client. If @code{req}
is GNUTLS_CERT_REQUIRE then the server will return an error if
the peer does not provide a certificate. If you do not
call this function then the client will not be asked to
send a certificate.
@end deftypefun

@subheading gnutls_certificate_client_set_retrieve_function
@anchor{gnutls_certificate_client_set_retrieve_function}
@deftypefun {void} {gnutls_certificate_client_set_retrieve_function} (gnutls_certificate_credentials_t @var{cred}, gnutls_certificate_client_retrieve_function * @var{func})
@var{cred}: is a @code{gnutls_certificate_credentials_t} structure.

@var{func}: is the callback function

This function sets a callback to be called in order to retrieve the certificate
to be used in the handshake.
The callback's function prototype is:
int (*callback)(gnutls_session_t, const gnutls_datum_t* req_ca_dn, int nreqs, 
gnutls_pk_algorithm_t* pk_algos, int pk_algos_length, gnutls_retr_st* st);

@code{st} should contain the certificates and private keys.

@code{req_ca_cert}, is only used in X.509 certificates. 
Contains a list with the CA names that the server considers trusted. 
Normally we should send a certificate that is signed
by one of these CAs. These names are DER encoded. To get a more
meaningful value use the function @code{gnutls_x509_rdn_get()}.

@code{pk_algos}, contains a list with server's acceptable signature algorithms.
The certificate returned should support the server's given algorithms.

If the callback function is provided then gnutls will call it, in the
handshake, after the certificate request message has been received.

The callback function should set the certificate list to be sent, and
return 0 on success. If no certificate was selected then the number of certificates
should be set to zero. The value (-1) indicates error and the handshake
will be terminated.
@end deftypefun

@subheading gnutls_certificate_server_set_retrieve_function
@anchor{gnutls_certificate_server_set_retrieve_function}
@deftypefun {void} {gnutls_certificate_server_set_retrieve_function} (gnutls_certificate_credentials_t @var{cred}, gnutls_certificate_server_retrieve_function * @var{func})
@var{cred}: is a @code{gnutls_certificate_credentials_t} structure.

@var{func}: is the callback function

This function sets a callback to be called in order to retrieve the certificate
to be used in the handshake.
The callback's function prototype is:
int (*callback)(gnutls_session_t, gnutls_retr_st* st);

@code{st} should contain the certificates and private keys.

If the callback function is provided then gnutls will call it, in the
handshake, after the certificate request message has been received.

The callback function should set the certificate list to be sent, and
return 0 on success.  The value (-1) indicates error and the handshake
will be terminated.
@end deftypefun

@subheading gnutls_certificate_verify_peers2
@anchor{gnutls_certificate_verify_peers2}
@deftypefun {int} {gnutls_certificate_verify_peers2} (gnutls_session_t @var{session}, unsigned int * @var{status})
@var{session}: is a gnutls session

@var{status}: is the output of the verification

This function will try to verify the peer's certificate and return
its status (trusted, invalid etc.).  The value of @code{status} should
be one or more of the gnutls_certificate_status_t enumerated
elements bitwise or'd. To avoid denial of service attacks some
default upper limits regarding the certificate key size and chain
size are set. To override them use
@code{gnutls_certificate_set_verify_limits()}.

Note that you must also check the peer's name in order to check if
the verified certificate belongs to the actual peer.

Returns a negative error code on error and zero on success.

This is the same as @code{gnutls_x509_verify_certificate()} and uses the
loaded CAs in the credentials as trusted CAs.

Note that some commonly used X.509 Certificate Authorities are
still using Version 1 certificates.  If you want to accept them,
you need to call @code{gnutls_certificate_set_verify_flags()} with, e.g.,
@code{GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT} parameter.
@end deftypefun

@subheading gnutls_certificate_verify_peers
@anchor{gnutls_certificate_verify_peers}
@deftypefun {int} {gnutls_certificate_verify_peers} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will try to verify the peer's certificate and return
its status (trusted, invalid etc.).  However you must also check
the peer's name in order to check if the verified certificate
belongs to the actual peer.

The return value should be one or more of the
gnutls_certificate_status_t enumerated elements bitwise or'd, or a
negative value on error.

This is the same as @code{gnutls_x509_verify_certificate()}.

@strong{Deprecated:} Use @code{gnutls_certificate_verify_peers2()} instead.
@end deftypefun

@subheading gnutls_certificate_expiration_time_peers
@anchor{gnutls_certificate_expiration_time_peers}
@deftypefun {time_t} {gnutls_certificate_expiration_time_peers} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the peer's certificate expiration time.

Returns (time_t) -1 on error.
@end deftypefun

@subheading gnutls_certificate_activation_time_peers
@anchor{gnutls_certificate_activation_time_peers}
@deftypefun {time_t} {gnutls_certificate_activation_time_peers} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the peer's certificate activation time.
This is the creation time for openpgp keys.

Returns (time_t) -1 on error.
@end deftypefun

@subheading gnutls_global_set_log_function
@anchor{gnutls_global_set_log_function}
@deftypefun {void} {gnutls_global_set_log_function} (gnutls_log_func @var{log_func})
@var{log_func}: it's a log function

This is the function where you set the logging function gnutls
is going to use. This function only accepts a character array.
Normally you may not use this function since it is only used 
for debugging purposes.

gnutls_log_func is of the form, 
void (*gnutls_log_func)( int level, const char*);
@end deftypefun

@subheading gnutls_global_set_log_level
@anchor{gnutls_global_set_log_level}
@deftypefun {void} {gnutls_global_set_log_level} (int @var{level})
@var{level}: it's an integer from 0 to 9. 

This is the function that allows you to set the log level.
The level is an integer between 0 and 9. Higher values mean
more verbosity. The default value is 0. Larger values should
only be used with care, since they may reveal sensitive information.

Use a log level over 10 to enable all debugging options.
@end deftypefun

@subheading gnutls_global_set_mem_functions
@anchor{gnutls_global_set_mem_functions}
@deftypefun {void} {gnutls_global_set_mem_functions} (gnutls_alloc_function @var{alloc_func}, gnutls_alloc_function      @var{secure_alloc_func}, gnutls_is_secure_function      @var{is_secure_func}, gnutls_realloc_function @var{realloc_func}, gnutls_free_function @var{free_func})
@var{alloc_func}: it's the default memory allocation function. Like @code{malloc()}.

@var{secure_alloc_func}: This is the memory allocation function that will be used for sensitive data.

@var{is_secure_func}: a function that returns 0 if the memory given is not secure. May be NULL.

@var{realloc_func}: A realloc function

@var{free_func}: The function that frees allocated data. Must accept a NULL pointer.

This is the function were you set the memory allocation functions gnutls
is going to use. By default the libc's allocation functions (@code{malloc()}, @code{free()}),
are used by gnutls, to allocate both sensitive and not sensitive data.
This function is provided to set the memory allocation functions to
something other than the defaults (ie the gcrypt allocation functions). 

This function must be called before @code{gnutls_global_init()} is called.
@end deftypefun

@subheading gnutls_global_init
@anchor{gnutls_global_init}
@deftypefun {int} {gnutls_global_init} ( @var{void})

This function initializes the global data to defaults.
Every gnutls application has a global data which holds common parameters
shared by gnutls session structures.
You must call @code{gnutls_global_deinit()} when gnutls usage is no longer needed
Returns zero on success.

Note that this function will also initialize libgcrypt, if it has not
been initialized before. Thus if you want to manually initialize libgcrypt
you must do it before calling this function. This is useful in cases you 
want to disable libgcrypt's internal lockings etc.

This function increment a global counter, so that
@code{gnutls_global_deinit()} only releases resources when it has been
called as many times as @code{gnutls_global_init()}.  This is useful when
GnuTLS is used by more than one library in an application.  This
function can be called many times, but will only do something the
first time.

Note!  This function is not thread safe.  If two threads call this
function simultaneously, they can cause a race between checking
the global counter and incrementing it, causing both threads to
execute the library initialization code.  That would lead to a
memory leak.  To handle this, your application could invoke this
function after aquiring a thread mutex.  To ignore the potential
memory leak is also an option.
@end deftypefun

@subheading gnutls_global_deinit
@anchor{gnutls_global_deinit}
@deftypefun {void} {gnutls_global_deinit} ( @var{void})

This function deinitializes the global data, that were initialized
using @code{gnutls_global_init()}.

Note!  This function is not thread safe.  See the discussion for
@code{gnutls_global_init()} for more information.
@end deftypefun

@subheading gnutls_transport_set_pull_function
@anchor{gnutls_transport_set_pull_function}
@deftypefun {void} {gnutls_transport_set_pull_function} (gnutls_session_t @var{session}, gnutls_pull_func @var{pull_func})
@var{session}: gnutls session

@var{pull_func}: a callback function similar to @code{read()}

This is the function where you set a function for gnutls 
to receive data. Normally, if you use berkeley style sockets,
do not need to use this function since the default (recv(2)) will 
probably be ok.

PULL_FUNC is of the form, 
ssize_t (*gnutls_pull_func)(gnutls_transport_ptr_t, void*, size_t);
@end deftypefun

@subheading gnutls_transport_set_push_function
@anchor{gnutls_transport_set_push_function}
@deftypefun {void} {gnutls_transport_set_push_function} (gnutls_session_t @var{session}, gnutls_push_func @var{push_func})
@var{session}: gnutls session

@var{push_func}: a callback function similar to @code{write()}

This is the function where you set a push function for gnutls
to use in order to send data. If you are going to use berkeley style
sockets, you do not need to use this function since
the default (send(2)) will probably be ok. Otherwise you should
specify this function for gnutls to be able to send data.

PUSH_FUNC is of the form, 
ssize_t (*gnutls_push_func)(gnutls_transport_ptr_t, const void*, size_t);
@end deftypefun

@subheading gnutls_check_version
@anchor{gnutls_check_version}
@deftypefun {const char *} {gnutls_check_version} (const char * @var{req_version})
@var{req_version}: the version to check

Check that the version of the library is at minimum the requested one
and return the version string; return NULL if the condition is not
satisfied.  If a NULL is passed to this function, no check is done,
but the version string is simply returned.
@end deftypefun

@subheading gnutls_anon_free_server_credentials
@anchor{gnutls_anon_free_server_credentials}
@deftypefun {void} {gnutls_anon_free_server_credentials} (gnutls_anon_server_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_anon_server_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it.
@end deftypefun

@subheading gnutls_anon_allocate_server_credentials
@anchor{gnutls_anon_allocate_server_credentials}
@deftypefun {int} {gnutls_anon_allocate_server_credentials} (gnutls_anon_server_credentials_t *       @var{sc})
@var{sc}: is a pointer to an @code{gnutls_anon_server_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_anon_free_client_credentials
@anchor{gnutls_anon_free_client_credentials}
@deftypefun {void} {gnutls_anon_free_client_credentials} (gnutls_anon_client_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_anon_client_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it.
@end deftypefun

@subheading gnutls_anon_allocate_client_credentials
@anchor{gnutls_anon_allocate_client_credentials}
@deftypefun {int} {gnutls_anon_allocate_client_credentials} (gnutls_anon_client_credentials_t *       @var{sc})
@var{sc}: is a pointer to an @code{gnutls_anon_client_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_anon_set_server_dh_params
@anchor{gnutls_anon_set_server_dh_params}
@deftypefun {void} {gnutls_anon_set_server_dh_params} (gnutls_anon_server_credentials_t @var{res}, gnutls_dh_params_t @var{dh_params})
@var{res}: is a gnutls_anon_server_credentials_t structure

@var{dh_params}: is a structure that holds diffie hellman parameters.

This function will set the diffie hellman parameters for an anonymous
server to use. These parameters will be used in Anonymous Diffie Hellman 
cipher suites.
@end deftypefun

@subheading gnutls_anon_set_server_params_function
@anchor{gnutls_anon_set_server_params_function}
@deftypefun {void} {gnutls_anon_set_server_params_function} (gnutls_anon_server_credentials_t @var{res}, gnutls_params_function * @var{func})
@var{res}: is a gnutls_certificate_credentials_t structure

@var{func}: is the function to be called

This function will set a callback in order for the server to get the 
diffie hellman parameters for anonymous authentication. The callback should
return zero on success.
@end deftypefun

@subheading gnutls_malloc
@anchor{gnutls_malloc}
@deftypefun {void *} {gnutls_malloc} (size_t @var{s})

This function will allocate 's' bytes data, and
return a pointer to memory. This function is supposed
to be used by callbacks.

The allocation function used is the one set by @code{gnutls_global_set_mem_functions()}.
@end deftypefun

@subheading gnutls_free
@anchor{gnutls_free}
@deftypefun {void} {gnutls_free} (void * @var{ptr})
This function will free data pointed by ptr.

The deallocation function used is the one set by @code{gnutls_global_set_mem_functions()}.
@end deftypefun

@subheading gnutls_dh_set_prime_bits
@anchor{gnutls_dh_set_prime_bits}
@deftypefun {void} {gnutls_dh_set_prime_bits} (gnutls_session_t @var{session}, unsigned int @var{bits})
@var{session}: is a @code{gnutls_session_t} structure.

@var{bits}: is the number of bits

This function sets the number of bits, for use in an 
Diffie Hellman key exchange. This is used both in DH ephemeral and
DH anonymous cipher suites. This will set the
minimum size of the prime that will be used for the handshake.

In the client side it sets the minimum accepted number of bits.
If a server sends a prime with less bits than that 
GNUTLS_E_DH_PRIME_UNACCEPTABLE will be returned by the
handshake.
@end deftypefun

@subheading gnutls_dh_get_group
@anchor{gnutls_dh_get_group}
@deftypefun {int} {gnutls_dh_get_group} (gnutls_session_t @var{session}, gnutls_datum_t * @var{raw_gen}, gnutls_datum_t * @var{raw_prime})
@var{session}: is a gnutls session

@var{raw_gen}: will hold the generator.

@var{raw_prime}: will hold the prime.

This function will return the group parameters used in the last Diffie Hellman 
authentication with the peer. These are the prime and the generator used.
This function should be used for both anonymous and ephemeral diffie Hellman.
The output parameters must be freed with @code{gnutls_free()}.

Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_dh_get_pubkey
@anchor{gnutls_dh_get_pubkey}
@deftypefun {int} {gnutls_dh_get_pubkey} (gnutls_session_t @var{session}, gnutls_datum_t * @var{raw_key})
@var{session}: is a gnutls session

@var{raw_key}: will hold the public key.

This function will return the peer's public key used in the last Diffie Hellman authentication.
This function should be used for both anonymous and ephemeral diffie Hellman.
The output parameters must be freed with @code{gnutls_free()}.

Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_rsa_export_get_pubkey
@anchor{gnutls_rsa_export_get_pubkey}
@deftypefun {int} {gnutls_rsa_export_get_pubkey} (gnutls_session_t @var{session}, gnutls_datum_t * @var{exponent}, gnutls_datum_t * @var{modulus})
@var{session}: is a gnutls session

@var{exponent}: will hold the exponent.

@var{modulus}: will hold the modulus.

This function will return the peer's public key exponent and
modulus used in the last RSA-EXPORT authentication.  The output
parameters must be freed with @code{gnutls_free()}.

Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_dh_get_secret_bits
@anchor{gnutls_dh_get_secret_bits}
@deftypefun {int} {gnutls_dh_get_secret_bits} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the bits used in the last Diffie Hellman authentication
with the peer. Should be used for both anonymous and ephemeral diffie Hellman.
Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_dh_get_prime_bits
@anchor{gnutls_dh_get_prime_bits}
@deftypefun {int} {gnutls_dh_get_prime_bits} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the bits of the prime used in the last Diffie Hellman authentication
with the peer. Should be used for both anonymous and ephemeral diffie Hellman.
Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_rsa_export_get_modulus_bits
@anchor{gnutls_rsa_export_get_modulus_bits}
@deftypefun {int} {gnutls_rsa_export_get_modulus_bits} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the bits used in the last RSA-EXPORT key exchange
with the peer. 
Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_dh_get_peers_public_bits
@anchor{gnutls_dh_get_peers_public_bits}
@deftypefun {int} {gnutls_dh_get_peers_public_bits} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the bits used in the last Diffie Hellman authentication
with the peer. Should be used for both anonymous and ephemeral diffie Hellman.
Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_certificate_get_ours
@anchor{gnutls_certificate_get_ours}
@deftypefun {const gnutls_datum_t *} {gnutls_certificate_get_ours} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the certificate as sent to the peer,
in the last handshake. These certificates are in raw format. 
In X.509 this is a certificate list. In OpenPGP this is a single
certificate.
Returns NULL in case of an error, or if no certificate was used.
@end deftypefun

@subheading gnutls_certificate_get_peers
@anchor{gnutls_certificate_get_peers}
@deftypefun {const gnutls_datum_t *} {gnutls_certificate_get_peers} (gnutls_session_t          @var{session}, unsigned int * @var{list_size})
@var{session}: is a gnutls session

@var{list_size}: is the length of the certificate list

This function will return the peer's raw certificate (chain) as 
sent by the peer. These certificates are in raw format (DER encoded 
for X.509). In case of a X.509 then a certificate list may be present. 
The first certificate in the list is the peer's certificate,
following the issuer's certificate, then the issuer's issuer etc.

In case of OpenPGP keys a single key will be returned
in raw format.

Returns NULL in case of an error, or if no certificate was sent.
@end deftypefun

@subheading gnutls_certificate_client_get_request_status
@anchor{gnutls_certificate_client_get_request_status}
@deftypefun {int} {gnutls_certificate_client_get_request_status} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return 0 if the peer (server) did not request client
authentication or 1 otherwise.
Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_fingerprint
@anchor{gnutls_fingerprint}
@deftypefun {int} {gnutls_fingerprint} (gnutls_digest_algorithm_t @var{algo}, const gnutls_datum_t * @var{data}, void * @var{result}, size_t * @var{result_size})
@var{algo}: is a digest algorithm

@var{data}: is the data

@var{result}: is the place where the result will be copied (may be null). 

@var{result_size}: should hold the size of the result. The actual size
of the returned result will also be copied there.

This function will calculate a fingerprint (actually a hash), of the
given data. The result is not printable data. You should convert it
to hex, or to something else printable.

This is the usual way to calculate a fingerprint of an X.509 
DER encoded certificate. Note however that the fingerprint 
of an OpenPGP is not just a hash and cannot be calculated with
this function.

Returns a negative value in case of an error.
@end deftypefun

@subheading gnutls_certificate_set_dh_params
@anchor{gnutls_certificate_set_dh_params}
@deftypefun {void} {gnutls_certificate_set_dh_params} (gnutls_certificate_credentials_t @var{res}, gnutls_dh_params_t @var{dh_params})
@var{res}: is a gnutls_certificate_credentials_t structure

@var{dh_params}: is a structure that holds diffie hellman parameters.

This function will set the diffie hellman parameters for a
certificate server to use. These parameters will be used in
Ephemeral Diffie Hellman cipher suites.  Note that only a pointer
to the parameters are stored in the certificate handle, so if you
deallocate the parameters before the certificate is deallocated,
you must change the parameters stored in the certificate first.
@end deftypefun

@subheading gnutls_certificate_set_params_function
@anchor{gnutls_certificate_set_params_function}
@deftypefun {void} {gnutls_certificate_set_params_function} (gnutls_certificate_credentials_t @var{res}, gnutls_params_function * @var{func})
@var{res}: is a gnutls_certificate_credentials_t structure

@var{func}: is the function to be called

This function will set a callback in order for the server to get the 
diffie hellman or RSA parameters for certificate authentication. The callback
should return zero on success.
@end deftypefun

@subheading gnutls_certificate_set_verify_flags
@anchor{gnutls_certificate_set_verify_flags}
@deftypefun {void} {gnutls_certificate_set_verify_flags} (gnutls_certificate_credentials_t          @var{res}, unsigned int @var{flags})
@var{res}: is a gnutls_certificate_credentials_t structure

@var{flags}: are the flags

This function will set the flags to be used at verification of the
certificates.  Flags must be OR of the
@code{gnutls_certificate_verify_flags} enumerations.
@end deftypefun

@subheading gnutls_certificate_set_verify_limits
@anchor{gnutls_certificate_set_verify_limits}
@deftypefun {void} {gnutls_certificate_set_verify_limits} (gnutls_certificate_credentials_t           @var{res}, unsigned int @var{max_bits}, unsigned int @var{max_depth})
@var{res}: is a gnutls_certificate_credentials structure

@var{max_bits}: is the number of bits of an acceptable certificate (default 8200)

@var{max_depth}: is maximum depth of the verification of a certificate chain (default 5)

This function will set some upper limits for the default verification function,
@code{gnutls_certificate_verify_peers2()}, to avoid denial of service attacks.
@end deftypefun

@subheading gnutls_certificate_set_rsa_export_params
@anchor{gnutls_certificate_set_rsa_export_params}
@deftypefun {void} {gnutls_certificate_set_rsa_export_params} (gnutls_certificate_credentials_t        @var{res}, gnutls_rsa_params_t @var{rsa_params})
@var{res}: is a gnutls_certificate_credentials_t structure

@var{rsa_params}: is a structure that holds temporary RSA parameters.

This function will set the temporary RSA parameters for a certificate
server to use. These parameters will be used in RSA-EXPORT
cipher suites.
@end deftypefun

@subheading gnutls_psk_set_params_function
@anchor{gnutls_psk_set_params_function}
@deftypefun {void} {gnutls_psk_set_params_function} (gnutls_psk_server_credentials_t @var{res}, gnutls_params_function * @var{func})
@var{res}: is a gnutls_psk_server_credentials_t structure

@var{func}: is the function to be called

This function will set a callback in order for the server to get the 
diffie hellman or RSA parameters for psk authentication. The callback
should return zero on success.
@end deftypefun

@subheading gnutls_anon_set_params_function
@anchor{gnutls_anon_set_params_function}
@deftypefun {void} {gnutls_anon_set_params_function} (gnutls_anon_server_credentials_t @var{res}, gnutls_params_function * @var{func})
@var{res}: is a gnutls_anon_server_credentials_t structure

@var{func}: is the function to be called

This function will set a callback in order for the server to get the 
diffie hellman or RSA parameters for anonymous authentication. The callback
should return zero on success.
@end deftypefun

@subheading gnutls_dh_params_import_raw
@anchor{gnutls_dh_params_import_raw}
@deftypefun {int} {gnutls_dh_params_import_raw} (gnutls_dh_params_t @var{dh_params}, const gnutls_datum_t * @var{prime}, const gnutls_datum_t * @var{generator})
@var{dh_params}: Is a structure that will hold the prime numbers

@var{prime}: holds the new prime

@var{generator}: holds the new generator

This function will replace the pair of prime and generator for use in
the Diffie-Hellman key exchange. The new parameters should be stored in the
appropriate gnutls_datum.
@end deftypefun

@subheading gnutls_dh_params_init
@anchor{gnutls_dh_params_init}
@deftypefun {int} {gnutls_dh_params_init} (gnutls_dh_params_t * @var{dh_params})
@var{dh_params}: Is a structure that will hold the prime numbers

This function will initialize the DH parameters structure.
@end deftypefun

@subheading gnutls_dh_params_deinit
@anchor{gnutls_dh_params_deinit}
@deftypefun {void} {gnutls_dh_params_deinit} (gnutls_dh_params_t @var{dh_params})
@var{dh_params}: Is a structure that holds the prime numbers

This function will deinitialize the DH parameters structure.
@end deftypefun

@subheading gnutls_dh_params_cpy
@anchor{gnutls_dh_params_cpy}
@deftypefun {int} {gnutls_dh_params_cpy} (gnutls_dh_params_t @var{dst}, gnutls_dh_params_t @var{src})
@var{dst}: Is the destination structure, which should be initialized.

@var{src}: Is the source structure

This function will copy the DH parameters structure from source
to destination.
@end deftypefun

@subheading gnutls_dh_params_generate2
@anchor{gnutls_dh_params_generate2}
@deftypefun {int} {gnutls_dh_params_generate2} (gnutls_dh_params_t @var{params}, unsigned int @var{bits})
@var{params}: Is the structure that the DH parameters will be stored

@var{bits}: is the prime's number of bits

This function will generate a new pair of prime and generator for use in 
the Diffie-Hellman key exchange. The new parameters will be allocated using
@code{gnutls_malloc()} and will be stored in the appropriate datum.
This function is normally slow. 

Note that the bits value should be one of 768, 1024, 2048, 3072 or 4096.
Also note that the DH parameters are only useful to servers.
Since clients use the parameters sent by the server, it's of
no use to call this in client side.
@end deftypefun

@subheading gnutls_dh_params_import_pkcs3
@anchor{gnutls_dh_params_import_pkcs3}
@deftypefun {int} {gnutls_dh_params_import_pkcs3} (gnutls_dh_params_t @var{params}, const gnutls_datum_t * @var{pkcs3_params}, gnutls_x509_crt_fmt_t @var{format})
@var{params}: A structure where the parameters will be copied to

@var{pkcs3_params}: should contain a PKCS3 DHParams structure PEM or DER encoded

@var{format}: the format of params. PEM or DER.

This function will extract the DHParams found in a PKCS3 formatted
structure. This is the format generated by "openssl dhparam" tool.

If the structure is PEM encoded, it should have a header
of "BEGIN DH PARAMETERS".

In case of failure a negative value will be returned, and
0 on success.
@end deftypefun

@subheading gnutls_dh_params_export_pkcs3
@anchor{gnutls_dh_params_export_pkcs3}
@deftypefun {int} {gnutls_dh_params_export_pkcs3} (gnutls_dh_params_t @var{params}, gnutls_x509_crt_fmt_t @var{format}, unsigned char * @var{params_data}, size_t * @var{params_data_size})
@var{params}: Holds the DH parameters

@var{format}: the format of output params. One of PEM or DER.

@var{params_data}: will contain a PKCS3 DHParams structure PEM or DER encoded

@var{params_data_size}: holds the size of params_data (and will be replaced by the actual size of parameters)

This function will export the given dh parameters to a PKCS3
DHParams structure. This is the format generated by "openssl dhparam" tool.
If the buffer provided is not long enough to hold the output, then
GNUTLS_E_SHORT_MEMORY_BUFFER will be returned.

If the structure is PEM encoded, it will have a header
of "BEGIN DH PARAMETERS".

In case of failure a negative value will be returned, and
0 on success.
@end deftypefun

@subheading gnutls_dh_params_export_raw
@anchor{gnutls_dh_params_export_raw}
@deftypefun {int} {gnutls_dh_params_export_raw} (gnutls_dh_params_t @var{params}, gnutls_datum_t * @var{prime}, gnutls_datum_t * @var{generator}, unsigned int * @var{bits})
@var{params}: Holds the DH parameters

@var{prime}: will hold the new prime

@var{generator}: will hold the new generator

@var{bits}: if non null will hold is the prime's number of bits

This function will export the pair of prime and generator for use in 
the Diffie-Hellman key exchange. The new parameters will be allocated using
@code{gnutls_malloc()} and will be stored in the appropriate datum.
@end deftypefun

@subheading gnutls_alert_get_name
@anchor{gnutls_alert_get_name}
@deftypefun {const char *} {gnutls_alert_get_name} (gnutls_alert_description_t @var{alert})
@var{alert}: is an alert number @code{gnutls_session_t} structure.

This function will return a string that describes the given alert
number or NULL.  See @code{gnutls_alert_get()}.
@end deftypefun

@subheading gnutls_alert_send
@anchor{gnutls_alert_send}
@deftypefun {int} {gnutls_alert_send} (gnutls_session_t @var{session}, gnutls_alert_level_t @var{level}, gnutls_alert_description_t @var{desc})
@var{session}: is a @code{gnutls_session_t} structure.

@var{level}: is the level of the alert

@var{desc}: is the alert description

This function will send an alert to the peer in order to inform
him of something important (eg. his Certificate could not be verified).
If the alert level is Fatal then the peer is expected to close the
connection, otherwise he may ignore the alert and continue.

The error code of the underlying record send function will be returned,
so you may also receive GNUTLS_E_INTERRUPTED or GNUTLS_E_AGAIN as well.

Returns 0 on success.
@end deftypefun

@subheading gnutls_error_to_alert
@anchor{gnutls_error_to_alert}
@deftypefun {int} {gnutls_error_to_alert} (int @var{err}, int * @var{level})
@var{err}: is a negative integer

@var{level}: the alert level will be stored there

Returns an alert depending on the error code returned by a gnutls
function. All alerts sent by this function should be considered fatal.
The only exception is when err == GNUTLS_E_REHANDSHAKE, where a warning 
alert should be sent to the peer indicating that no renegotiation will 
be performed.

If the return value is GNUTLS_E_INVALID_REQUEST, then there was no
mapping to an alert.
@end deftypefun

@subheading gnutls_alert_send_appropriate
@anchor{gnutls_alert_send_appropriate}
@deftypefun {int} {gnutls_alert_send_appropriate} (gnutls_session_t @var{session}, int @var{err})
@var{session}: is a @code{gnutls_session_t} structure.

@var{err}: is an integer

Sends an alert to the peer depending on the error code returned by a gnutls
function. This function will call @code{gnutls_error_to_alert()} to determine
the appropriate alert to send.

This function may also return GNUTLS_E_AGAIN, or GNUTLS_E_INTERRUPTED.

If the return value is GNUTLS_E_INVALID_REQUEST, then no alert has
been sent to the peer.

Returns zero on success.
@end deftypefun

@subheading gnutls_alert_get
@anchor{gnutls_alert_get}
@deftypefun {gnutls_alert_description_t} {gnutls_alert_get} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function will return the last alert number received. This
function should be called if GNUTLS_E_WARNING_ALERT_RECEIVED or
GNUTLS_E_FATAL_ALERT_RECEIVED has been returned by a gnutls
function.  The peer may send alerts if he thinks some things were
not right. Check gnutls.h for the available alert descriptions.

If no alert has been received the returned value is undefined.
@end deftypefun

@subheading gnutls_cipher_get
@anchor{gnutls_cipher_get}
@deftypefun {gnutls_cipher_algorithm_t} {gnutls_cipher_get} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the currently used cipher.
@end deftypefun

@subheading gnutls_certificate_type_get
@anchor{gnutls_certificate_type_get}
@deftypefun {gnutls_certificate_type_t} {gnutls_certificate_type_get} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the currently used certificate type. The certificate type
is by default X.509, unless it is negotiated as a TLS extension.
@end deftypefun

@subheading gnutls_kx_get
@anchor{gnutls_kx_get}
@deftypefun {gnutls_kx_algorithm_t} {gnutls_kx_get} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the key exchange algorithm used in the last handshake.
@end deftypefun

@subheading gnutls_mac_get
@anchor{gnutls_mac_get}
@deftypefun {gnutls_mac_algorithm_t} {gnutls_mac_get} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the currently used mac algorithm.
@end deftypefun

@subheading gnutls_compression_get
@anchor{gnutls_compression_get}
@deftypefun {gnutls_compression_method_t} {gnutls_compression_get} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Returns the currently used compression method.
@end deftypefun

@subheading gnutls_init
@anchor{gnutls_init}
@deftypefun {int} {gnutls_init} (gnutls_session_t * @var{session}, gnutls_connection_end_t @var{con_end})
@var{session}: is a pointer to a @code{gnutls_session_t} structure.

@var{con_end}: is used to indicate if this session is to be used for server or 
client. Can be one of GNUTLS_CLIENT and GNUTLS_SERVER. 

This function initializes the current session to null. Every session
must be initialized before use, so internal structures can be allocated.
This function allocates structures which can only be free'd
by calling @code{gnutls_deinit()}. Returns zero on success.
@end deftypefun

@subheading gnutls_deinit
@anchor{gnutls_deinit}
@deftypefun {void} {gnutls_deinit} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function clears all buffers associated with the @code{session}.
This function will also remove session data from the session database
if the session was terminated abnormally.
@end deftypefun

@subheading gnutls_openpgp_send_key
@anchor{gnutls_openpgp_send_key}
@deftypefun {void} {gnutls_openpgp_send_key} (gnutls_session_t @var{session}, gnutls_openpgp_key_status_t @var{status})
@var{session}: is a pointer to a @code{gnutls_session_t} structure.

@var{status}: is one of OPENPGP_KEY, or OPENPGP_KEY_FINGERPRINT

This function will order gnutls to send the key fingerprint instead
of the key in the initial handshake procedure. This should be used
with care and only when there is indication or knowledge that the 
server can obtain the client's key.
@end deftypefun

@subheading gnutls_certificate_send_x509_rdn_sequence
@anchor{gnutls_certificate_send_x509_rdn_sequence}
@deftypefun {void} {gnutls_certificate_send_x509_rdn_sequence} (gnutls_session_t @var{session}, int @var{status})
@var{session}: is a pointer to a @code{gnutls_session_t} structure.

@var{status}: is 0 or 1

If status is non zero, this function will order gnutls not to send the rdnSequence 
in the certificate request message. That is the server will not advertize
it's trusted CAs to the peer. If status is zero then the default behaviour will
take effect, which is to advertize the server's trusted CAs.

This function has no effect in clients, and in authentication methods other than
certificate with X.509 certificates.
@end deftypefun

@subheading gnutls_handshake_set_private_extensions
@anchor{gnutls_handshake_set_private_extensions}
@deftypefun {void} {gnutls_handshake_set_private_extensions} (gnutls_session_t @var{session}, int @var{allow})
@var{session}: is a @code{gnutls_session_t} structure.

@var{allow}: is an integer (0 or 1)

This function will enable or disable the use of private
cipher suites (the ones that start with 0xFF). By default 
or if @code{allow} is 0 then these cipher suites will not be
advertized nor used.

Unless this function is called with the option to allow (1), then
no compression algorithms, like LZO. That is because these algorithms
are not yet defined in any RFC or even internet draft.

Enabling the private ciphersuites when talking to other than gnutls
servers and clients may cause interoperability problems.
@end deftypefun

@subheading gnutls_prf_raw
@anchor{gnutls_prf_raw}
@deftypefun {int} {gnutls_prf_raw} (gnutls_session_t @var{session}, size_t @var{label_size}, const char * @var{label}, size_t @var{seed_size}, const char * @var{seed}, size_t @var{outsize}, char * @var{out})
@var{session}: is a @code{gnutls_session_t} structure.

@var{label_size}: length of the @code{label} variable.

@var{label}: label used in PRF computation, typically a short string.

@var{seed_size}: length of the @code{seed} variable.

@var{seed}: optional extra data to seed the PRF with.

@var{outsize}: size of pre-allocated output buffer to hold the output.

@var{out}: pre-allocate buffer to hold the generated data.

Apply the TLS Pseudo-Random-Function (PRF) using the master secret
on some data.

The @code{label} variable usually contain a string denoting the purpose
for the generated data.  The @code{seed} usually contain data such as the
client and server random, perhaps together with some additional
data that is added to guarantee uniqueness of the output for a
particular purpose.

Because the output is not guaranteed to be unique for a particular
session unless @code{seed} include the client random and server random
fields (the PRF would output the same data on another connection
resumed from the first one), it is not recommended to use this
function directly.  The @code{gnutls_prf()} function seed the PRF with the
client and server random fields directly, and is recommended if you
want to generate pseudo random data unique for each session.

@strong{Return value:} Return 0 on success, or an error code.
@end deftypefun

@subheading gnutls_prf
@anchor{gnutls_prf}
@deftypefun {int} {gnutls_prf} (gnutls_session_t @var{session}, size_t @var{label_size}, const char * @var{label}, int @var{server_random_first}, size_t @var{extra_size}, const char * @var{extra}, size_t @var{outsize}, char * @var{out})
@var{session}: is a @code{gnutls_session_t} structure.

@var{label_size}: length of the @code{label} variable.

@var{label}: label used in PRF computation, typically a short string.

@var{server_random_first}: non-0 if server random field should be first in seed

@var{extra_size}: length of the @code{extra} variable.

@var{extra}: optional extra data to seed the PRF with.

@var{outsize}: size of pre-allocated output buffer to hold the output.

@var{out}: pre-allocate buffer to hold the generated data.

Apply the TLS Pseudo-Random-Function (PRF) using the master secret
on some data, seeded with the client and server random fields.

The @code{label} variable usually contain a string denoting the purpose
for the generated data.  The @code{server_random_first} indicate whether
the client random field or the server random field should be first
in the seed.  Non-0 indicate that the server random field is first,
0 that the client random field is first.

The @code{extra} variable can be used to add more data to the seed, after
the random variables.  It can be used to tie make sure the
generated output is strongly connected to some additional data
(e.g., a string used in user authentication).

The output is placed in *@code{OUT}, which must be pre-allocated.

@strong{Return value:} Return 0 on success, or an error code.
@end deftypefun

@subheading gnutls_session_get_client_random
@anchor{gnutls_session_get_client_random}
@deftypefun {const void *} {gnutls_session_get_client_random} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Return a pointer to the 32-byte client random field used in the
session.  The pointer must not be modified or deallocated.

If a client random value has not yet been established, the output
will be garbage; in particular, a @code{NULL} return value should not be
expected.

@strong{Return value:} pointer to client random.
@end deftypefun

@subheading gnutls_session_get_server_random
@anchor{gnutls_session_get_server_random}
@deftypefun {const void *} {gnutls_session_get_server_random} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Return a pointer to the 32-byte server random field used in the
session.  The pointer must not be modified or deallocated.

If a server random value has not yet been established, the output
will be garbage; in particular, a @code{NULL} return value should not be
expected.

@strong{Return value:} pointer to server random.
@end deftypefun

@subheading gnutls_session_get_master_secret
@anchor{gnutls_session_get_master_secret}
@deftypefun {const void *} {gnutls_session_get_master_secret} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

Return a pointer to the 48-byte master secret in the session.  The
pointer must not be modified or deallocated.

If a master secret value has not yet been established, the output
will be garbage; in particular, a @code{NULL} return value should not be
expected.

Consider using @code{gnutls_prf()} rather than extracting the master
secret and use it to derive further data.

@strong{Return value:} pointer to master secret.
@end deftypefun

@subheading gnutls_session_is_resumed
@anchor{gnutls_session_is_resumed}
@deftypefun {int} {gnutls_session_is_resumed} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function will return non zero if this session is a resumed one,
or a zero if this is a new session.
@end deftypefun

@subheading gnutls_session_get_ptr
@anchor{gnutls_session_get_ptr}
@deftypefun {void *} {gnutls_session_get_ptr} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function will return the user given pointer from the session structure.
This is the pointer set with @code{gnutls_session_set_ptr()}.
@end deftypefun

@subheading gnutls_session_set_ptr
@anchor{gnutls_session_set_ptr}
@deftypefun {void} {gnutls_session_set_ptr} (gnutls_session_t @var{session}, void * @var{ptr})
@var{session}: is a @code{gnutls_session_t} structure.

@var{ptr}: is the user pointer

This function will set (associate) the user given pointer to the
session structure.  This is pointer can be accessed with
@code{gnutls_session_get_ptr()}.
@end deftypefun

@subheading gnutls_record_get_direction
@anchor{gnutls_record_get_direction}
@deftypefun {int} {gnutls_record_get_direction} (gnutls_session_t @var{session})
@var{session}: is a @code{gnutls_session_t} structure.

This function provides information about the internals of the record
protocol and is only useful if a prior gnutls function call (e.g.
@code{gnutls_handshake()}) was interrupted for some reason, that is, if a function
returned GNUTLS_E_INTERRUPTED or GNUTLS_E_AGAIN. In such a case, you might
want to call @code{select()} or @code{poll()} before calling the interrupted gnutls
function again. To tell you whether a file descriptor should be selected
for either reading or writing, @code{gnutls_record_get_direction()} returns 0 if
the interrupted function was trying to read data, and 1 if it was trying to
write data.
@end deftypefun

@subheading gnutls_certificate_set_x509_key_mem
@anchor{gnutls_certificate_set_x509_key_mem}
@deftypefun {int} {gnutls_certificate_set_x509_key_mem} (gnutls_certificate_credentials_t          @var{res}, const gnutls_datum_t * @var{cert}, const gnutls_datum_t * @var{key}, gnutls_x509_crt_fmt_t @var{type})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{cert}: contains a certificate list (path) for the specified private key

@var{key}: is the private key

@var{type}: is PEM or DER

This function sets a certificate/private key pair in the 
gnutls_certificate_credentials_t structure. This function may be called
more than once (in case multiple keys/certificates exist for the
server).

@strong{Currently are supported:} RSA PKCS-1 encoded private keys, 
DSA private keys.

DSA private keys are encoded the OpenSSL way, which is an ASN.1
DER sequence of 6 INTEGERs - version, p, q, g, pub, priv.

Note that the keyUsage (2.5.29.15) PKIX extension in X.509 certificates 
is supported. This means that certificates intended for signing cannot
be used for ciphersuites that require encryption.

If the certificate and the private key are given in PEM encoding
then the strings that hold their values must be null terminated.
@end deftypefun

@subheading gnutls_certificate_set_x509_key
@anchor{gnutls_certificate_set_x509_key}
@deftypefun {int} {gnutls_certificate_set_x509_key} (gnutls_certificate_credentials_t @var{res}, gnutls_x509_crt_t * @var{cert_list}, int @var{cert_list_size}, gnutls_x509_privkey_t @var{key})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{cert_list}: contains a certificate list (path) for the specified private key

@var{cert_list_size}: holds the size of the certificate list

@var{key}: is a gnutls_x509_privkey_t key

This function sets a certificate/private key pair in the 
gnutls_certificate_credentials_t structure. This function may be called
more than once (in case multiple keys/certificates exist for the
server).
@end deftypefun

@subheading gnutls_certificate_set_x509_key_file
@anchor{gnutls_certificate_set_x509_key_file}
@deftypefun {int} {gnutls_certificate_set_x509_key_file} (gnutls_certificate_credentials_t           @var{res}, const char * @var{CERTFILE}, const char * @var{KEYFILE}, gnutls_x509_crt_fmt_t @var{type})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{CERTFILE}: is a file that containing the certificate list (path) for
the specified private key, in PKCS7 format, or a list of certificates

@var{KEYFILE}: is a file that contains the private key

@var{type}: is PEM or DER

This function sets a certificate/private key pair in the 
gnutls_certificate_credentials_t structure. This function may be called
more than once (in case multiple keys/certificates exist for the
server).

Currently only PKCS-1 encoded RSA and DSA private keys are accepted by
this function.
@end deftypefun

@subheading gnutls_certificate_set_x509_trust_mem
@anchor{gnutls_certificate_set_x509_trust_mem}
@deftypefun {int} {gnutls_certificate_set_x509_trust_mem} (gnutls_certificate_credentials_t            @var{res}, const gnutls_datum_t * @var{ca}, gnutls_x509_crt_fmt_t @var{type})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{ca}: is a list of trusted CAs or a DER certificate

@var{type}: is DER or PEM

This function adds the trusted CAs in order to verify client
or server certificates. In case of a client this is not required
to be called if the certificates are not verified using
@code{gnutls_certificate_verify_peers2()}.
This function may be called multiple times.

In case of a server the CAs set here will be sent to the client if
a certificate request is sent. This can be disabled using
@code{gnutls_certificate_send_x509_rdn_sequence()}.

Returns the number of certificates processed or a negative
value on error.
@end deftypefun

@subheading gnutls_certificate_set_x509_trust
@anchor{gnutls_certificate_set_x509_trust}
@deftypefun {int} {gnutls_certificate_set_x509_trust} (gnutls_certificate_credentials_t @var{res}, gnutls_x509_crt_t * @var{ca_list}, int @var{ca_list_size})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{ca_list}: is a list of trusted CAs

@var{ca_list_size}: holds the size of the CA list

This function adds the trusted CAs in order to verify client
or server certificates. In case of a client this is not required
to be called if the certificates are not verified using
@code{gnutls_certificate_verify_peers2()}.
This function may be called multiple times.

In case of a server the CAs set here will be sent to the client if
a certificate request is sent. This can be disabled using
@code{gnutls_certificate_send_x509_rdn_sequence()}.

Returns 0 on success.
@end deftypefun

@subheading gnutls_certificate_set_x509_trust_file
@anchor{gnutls_certificate_set_x509_trust_file}
@deftypefun {int} {gnutls_certificate_set_x509_trust_file} (gnutls_certificate_credentials_t      @var{res}, const char * @var{cafile}, gnutls_x509_crt_fmt_t @var{type})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{cafile}: is a file containing the list of trusted CAs (DER or PEM list)

@var{type}: is PEM or DER

This function adds the trusted CAs in order to verify client
or server certificates. In case of a client this is not required
to be called if the certificates are not verified using
@code{gnutls_certificate_verify_peers2()}.
This function may be called multiple times.

In case of a server the names of the CAs set here will be sent to the 
client if a certificate request is sent. This can be disabled using
@code{gnutls_certificate_send_x509_rdn_sequence()}.

Returns the number of certificates processed or a negative
value on error.
@end deftypefun

@subheading gnutls_certificate_set_x509_crl_mem
@anchor{gnutls_certificate_set_x509_crl_mem}
@deftypefun {int} {gnutls_certificate_set_x509_crl_mem} (gnutls_certificate_credentials_t          @var{res}, const gnutls_datum_t * @var{CRL}, gnutls_x509_crt_fmt_t @var{type})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{CRL}: is a list of trusted CRLs. They should have been verified before.

@var{type}: is DER or PEM

This function adds the trusted CRLs in order to verify client or server
certificates.  In case of a client this is not required
to be called if the certificates are not verified using
@code{gnutls_certificate_verify_peers2()}.
This function may be called multiple times.

Returns the number of CRLs processed or a negative value on error.
@end deftypefun

@subheading gnutls_certificate_set_x509_crl
@anchor{gnutls_certificate_set_x509_crl}
@deftypefun {int} {gnutls_certificate_set_x509_crl} (gnutls_certificate_credentials_t @var{res}, gnutls_x509_crl_t * @var{crl_list}, int @var{crl_list_size})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{crl_list}: is a list of trusted CRLs. They should have been verified before.

@var{crl_list_size}: holds the size of the crl_list

This function adds the trusted CRLs in order to verify client or server
certificates.  In case of a client this is not required
to be called if the certificates are not verified using
@code{gnutls_certificate_verify_peers2()}.
This function may be called multiple times.

Returns 0 on success.
@end deftypefun

@subheading gnutls_certificate_set_x509_crl_file
@anchor{gnutls_certificate_set_x509_crl_file}
@deftypefun {int} {gnutls_certificate_set_x509_crl_file} (gnutls_certificate_credentials_t           @var{res}, const char * @var{crlfile}, gnutls_x509_crt_fmt_t @var{type})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{crlfile}: is a file containing the list of verified CRLs (DER or PEM list)

@var{type}: is PEM or DER

This function adds the trusted CRLs in order to verify client or server
certificates.  In case of a client this is not required
to be called if the certificates are not verified using
@code{gnutls_certificate_verify_peers2()}.
This function may be called multiple times.

Returns the number of CRLs processed or a negative value on error.
@end deftypefun

@subheading gnutls_certificate_set_x509_simple_pkcs12_file
@anchor{gnutls_certificate_set_x509_simple_pkcs12_file}
@deftypefun {int} {gnutls_certificate_set_x509_simple_pkcs12_file} (gnutls_certificate_credentials_t @var{res}, const char * @var{pkcs12file}, gnutls_x509_crt_fmt_t @var{type}, const char * @var{password})
@var{res}: is an @code{gnutls_certificate_credentials_t} structure.

@var{pkcs12file}: filename of file containing PKCS@code{12} blob.

@var{type}: is PEM or DER of the @code{pkcs12file}.

@var{password}: optional password used to decrypt PKCS@code{12} file, bags and keys.

This function sets a certificate/private key pair and/or a CRL in
the gnutls_certificate_credentials_t structure.  This function may
be called more than once (in case multiple keys/certificates exist
for the server).

@strong{MAC:} ed PKCS@code{12} files are supported.  Encrypted PKCS@code{12} bags are
supported.  Encrypted PKCS@code{8} private keys are supported.  However,
only password based security, and the same password for all
operations, are supported.

The private keys may be RSA PKCS@code{1} or DSA private keys encoded in
the OpenSSL way.

PKCS@code{12} file may contain many keys and/or certificates, and there
is no way to identify which key/certificate pair you want.  You
should make sure the PKCS@code{12} file only contain one key/certificate
pair and/or one CRL.

It is believed that the limitations of this function is acceptable
for most usage, and that any more flexibility would introduce
complexity that would make it harder to use this functionality at
all.

@strong{Return value:} Returns 0 on success, or an error code.
@end deftypefun

@subheading gnutls_certificate_free_crls
@anchor{gnutls_certificate_free_crls}
@deftypefun {void} {gnutls_certificate_free_crls} (gnutls_certificate_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_certificate_credentials_t} structure.

This function will delete all the CRLs associated
with the given credentials.
@end deftypefun

@subheading gnutls_rsa_params_import_raw
@anchor{gnutls_rsa_params_import_raw}
@deftypefun {int} {gnutls_rsa_params_import_raw} (gnutls_rsa_params_t @var{rsa_params}, const gnutls_datum_t * @var{m}, const gnutls_datum_t * @var{e}, const gnutls_datum_t * @var{d}, const gnutls_datum_t * @var{p}, const gnutls_datum_t * @var{q}, const gnutls_datum_t * @var{u})
@var{rsa_params}: Is a structure will hold the parameters

@var{m}: holds the modulus

@var{e}: holds the public exponent

@var{d}: holds the private exponent

@var{p}: holds the first prime (p)

@var{q}: holds the second prime (q)

@var{u}: holds the coefficient

This function will replace the parameters in the given structure.
The new parameters should be stored in the appropriate gnutls_datum. 
@end deftypefun

@subheading gnutls_rsa_params_init
@anchor{gnutls_rsa_params_init}
@deftypefun {int} {gnutls_rsa_params_init} (gnutls_rsa_params_t * @var{rsa_params})
@var{rsa_params}: Is a structure that will hold the parameters

This function will initialize the temporary RSA parameters structure.
@end deftypefun

@subheading gnutls_rsa_params_deinit
@anchor{gnutls_rsa_params_deinit}
@deftypefun {void} {gnutls_rsa_params_deinit} (gnutls_rsa_params_t @var{rsa_params})
@var{rsa_params}: Is a structure that holds the parameters

This function will deinitialize the RSA parameters structure.
@end deftypefun

@subheading gnutls_rsa_params_cpy
@anchor{gnutls_rsa_params_cpy}
@deftypefun {int} {gnutls_rsa_params_cpy} (gnutls_rsa_params_t @var{dst}, gnutls_rsa_params_t @var{src})
@var{dst}: Is the destination structure, which should be initialized.

@var{src}: Is the source structure

This function will copy the RSA parameters structure from source
to destination.
@end deftypefun

@subheading gnutls_rsa_params_generate2
@anchor{gnutls_rsa_params_generate2}
@deftypefun {int} {gnutls_rsa_params_generate2} (gnutls_rsa_params_t @var{params}, unsigned int @var{bits})
@var{params}: The structure where the parameters will be stored

@var{bits}: is the prime's number of bits

This function will generate new temporary RSA parameters for use in 
RSA-EXPORT ciphersuites.  This function is normally slow. 

Note that if the parameters are to be used in export cipher suites the 
bits value should be 512 or less.
Also note that the generation of new RSA parameters is only useful
to servers. Clients use the parameters sent by the server, thus it's
no use calling this in client side.
@end deftypefun

@subheading gnutls_rsa_params_import_pkcs1
@anchor{gnutls_rsa_params_import_pkcs1}
@deftypefun {int} {gnutls_rsa_params_import_pkcs1} (gnutls_rsa_params_t @var{params}, const gnutls_datum_t * @var{pkcs1_params}, gnutls_x509_crt_fmt_t @var{format})
@var{params}: A structure where the parameters will be copied to

@var{pkcs1_params}: should contain a PKCS1 RSAPublicKey structure PEM or DER encoded

@var{format}: the format of params. PEM or DER.

This function will extract the RSAPublicKey found in a PKCS1 formatted
structure. 

If the structure is PEM encoded, it should have a header
of "BEGIN RSA PRIVATE KEY".

In case of failure a negative value will be returned, and
0 on success.
@end deftypefun

@subheading gnutls_rsa_params_export_pkcs1
@anchor{gnutls_rsa_params_export_pkcs1}
@deftypefun {int} {gnutls_rsa_params_export_pkcs1} (gnutls_rsa_params_t @var{params}, gnutls_x509_crt_fmt_t @var{format}, unsigned char * @var{params_data}, size_t * @var{params_data_size})
@var{params}: Holds the RSA parameters

@var{format}: the format of output params. One of PEM or DER.

@var{params_data}: will contain a PKCS1 RSAPublicKey structure PEM or DER encoded

@var{params_data_size}: holds the size of params_data (and will be replaced by the actual size of parameters)

This function will export the given RSA parameters to a PKCS1
RSAPublicKey structure. If the buffer provided is not long enough to 
hold the output, then GNUTLS_E_SHORT_MEMORY_BUFFER will be returned.

If the structure is PEM encoded, it will have a header
of "BEGIN RSA PRIVATE KEY".

In case of failure a negative value will be returned, and
0 on success.
@end deftypefun

@subheading gnutls_rsa_params_export_raw
@anchor{gnutls_rsa_params_export_raw}
@deftypefun {int} {gnutls_rsa_params_export_raw} (gnutls_rsa_params_t @var{params}, gnutls_datum_t * @var{m}, gnutls_datum_t * @var{e}, gnutls_datum_t * @var{d}, gnutls_datum_t * @var{p}, gnutls_datum_t * @var{q}, gnutls_datum_t * @var{u}, unsigned int * @var{bits})
@var{params}: a structure that holds the rsa parameters

@var{m}: will hold the modulus

@var{e}: will hold the public exponent

@var{d}: will hold the private exponent

@var{p}: will hold the first prime (p)

@var{q}: will hold the second prime (q)

@var{u}: will hold the coefficient

@var{bits}: if non null will hold the prime's number of bits

This function will export the RSA parameters found in the given
structure. The new parameters will be allocated using
@code{gnutls_malloc()} and will be stored in the appropriate datum.
@end deftypefun

@subheading gnutls_server_name_get
@anchor{gnutls_server_name_get}
@deftypefun {int} {gnutls_server_name_get} (gnutls_session_t @var{session}, void * @var{data}, size_t * @var{data_length}, unsigned int * @var{type}, unsigned int @var{indx})
@var{session}: is a @code{gnutls_session_t} structure.

@var{data}: will hold the data

@var{data_length}: will hold the data length. Must hold the maximum size of data.

@var{type}: will hold the server name indicator type

@var{indx}: is the index of the server_name

This function will allow you to get the name indication (if any),
a client has sent. The name indication may be any of the enumeration
gnutls_server_name_type_t.

If @code{type} is GNUTLS_NAME_DNS, then this function is to be used by servers
that support virtual hosting, and the data will be a null terminated UTF-8 string.

If @code{data} has not enough size to hold the server name GNUTLS_E_SHORT_MEMORY_BUFFER
is returned, and @code{data_length} will hold the required size.

@code{index} is used to retrieve more than one server names (if sent by the client).
The first server name has an index of 0, the second 1 and so on. If no name with the given
index exists GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE is returned.
@end deftypefun

@subheading gnutls_server_name_set
@anchor{gnutls_server_name_set}
@deftypefun {int} {gnutls_server_name_set} (gnutls_session_t @var{session}, gnutls_server_name_type_t @var{type}, const void * @var{name}, size_t @var{name_length})
@var{session}: is a @code{gnutls_session_t} structure.

@var{type}: specifies the indicator type

@var{name}: is a string that contains the server name.

@var{name_length}: holds the length of name

This function is to be used by clients that want to inform 
(via a TLS extension mechanism) the server of the name they
connected to. This should be used by clients that connect
to servers that do virtual hosting.

The value of @code{name} depends on the @code{ind} type. In case of GNUTLS_NAME_DNS,
an ASCII or UTF-8 null terminated string, without the trailing dot, is expected. 
IPv4 or IPv6 addresses are not permitted.
@end deftypefun

@subheading gnutls_srp_free_client_credentials
@anchor{gnutls_srp_free_client_credentials}
@deftypefun {void} {gnutls_srp_free_client_credentials} (gnutls_srp_client_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_srp_client_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it.
@end deftypefun

@subheading gnutls_srp_allocate_client_credentials
@anchor{gnutls_srp_allocate_client_credentials}
@deftypefun {int} {gnutls_srp_allocate_client_credentials} (gnutls_srp_client_credentials_t * @var{sc})
@var{sc}: is a pointer to an @code{gnutls_srp_server_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

Returns 0 on success.
@end deftypefun

@subheading gnutls_srp_set_client_credentials
@anchor{gnutls_srp_set_client_credentials}
@deftypefun {int} {gnutls_srp_set_client_credentials} (gnutls_srp_client_credentials_t @var{res}, const char * @var{username}, const char * @var{password})
@var{res}: is an @code{gnutls_srp_client_credentials_t} structure.

@var{username}: is the user's userid

@var{password}: is the user's password

This function sets the username and password, in a gnutls_srp_client_credentials_t structure.
Those will be used in SRP authentication. @code{username} and @code{password} should be ASCII
strings or UTF-8 strings prepared using the "SASLprep" profile of "stringprep".

Returns 0 on success.
@end deftypefun

@subheading gnutls_srp_free_server_credentials
@anchor{gnutls_srp_free_server_credentials}
@deftypefun {void} {gnutls_srp_free_server_credentials} (gnutls_srp_server_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_srp_server_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it.
@end deftypefun

@subheading gnutls_srp_allocate_server_credentials
@anchor{gnutls_srp_allocate_server_credentials}
@deftypefun {int} {gnutls_srp_allocate_server_credentials} (gnutls_srp_server_credentials_t * @var{sc})
@var{sc}: is a pointer to an @code{gnutls_srp_server_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

Returns 0 on success.
@end deftypefun

@subheading gnutls_srp_set_server_credentials_file
@anchor{gnutls_srp_set_server_credentials_file}
@deftypefun {int} {gnutls_srp_set_server_credentials_file} (gnutls_srp_server_credentials_t      @var{res}, const char * @var{password_file}, const char * @var{password_conf_file})
@var{res}: is an @code{gnutls_srp_server_credentials_t} structure.

@var{password_file}: is the SRP password file (tpasswd)

@var{password_conf_file}: is the SRP password conf file (tpasswd.conf)

This function sets the password files, in a gnutls_srp_server_credentials_t structure.
Those password files hold usernames and verifiers and will be used for SRP authentication.

Returns 0 on success.
@end deftypefun

@subheading gnutls_srp_set_server_credentials_function
@anchor{gnutls_srp_set_server_credentials_function}
@deftypefun {void} {gnutls_srp_set_server_credentials_function} (gnutls_srp_server_credentials_t          @var{cred}, gnutls_srp_server_credentials_function          * @var{func})
@var{cred}: is a @code{gnutls_srp_server_credentials_t} structure.

@var{func}: is the callback function

This function can be used to set a callback to retrieve the user's SRP credentials.
The callback's function form is:
int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t* salt, gnutls_datum_t *verifier, gnutls_datum_t* g,
gnutls_datum_t* n);

@code{username} contains the actual username. 
The @code{salt}, @code{verifier}, @code{generator} and @code{prime} must be filled
in using the @code{gnutls_malloc()}. For convenience @code{prime} and @code{generator} 
may also be one of the static parameters defined in extra.h.

In case the callback returned a negative number then gnutls will
assume that the username does not exist.

In order to prevent attackers from guessing valid usernames,
if a user does not exist, g and n values should be filled in
using a random user's parameters. In that case the callback must
return the special value (1).

The callback function will only be called once per handshake.
The callback function should return 0 on success, while
-1 indicates an error.
@end deftypefun

@subheading gnutls_srp_set_client_credentials_function
@anchor{gnutls_srp_set_client_credentials_function}
@deftypefun {void} {gnutls_srp_set_client_credentials_function} (gnutls_srp_client_credentials_t          @var{cred}, gnutls_srp_client_credentials_function          * @var{func})
@var{cred}: is a @code{gnutls_srp_server_credentials_t} structure.

@var{func}: is the callback function

This function can be used to set a callback to retrieve the username and
password for client SRP authentication.
The callback's function form is:
int (*callback)(gnutls_session_t, unsigned int times, char** username,
char** password);

The @code{username} and @code{password} must be allocated using @code{gnutls_malloc()}.
@code{times} will be 0 the first time called, and 1 the second.
@code{username} and @code{password} should be ASCII strings or UTF-8 strings 
prepared using the "SASLprep" profile of "stringprep".

The callback function will be called once or twice per handshake.
The first time called, is before the ciphersuite is negotiated.
At that time if the callback returns a negative error code,
the callback will be called again if SRP has been
negotiated. This uses a special TLS-SRP idiom in order to avoid
asking the user for SRP password and username if the server does
not support SRP.

The callback should not return a negative error code the second
time called, since the handshake procedure will be aborted.

The callback function should return 0 on success.
-1 indicates an error.
@end deftypefun

@subheading gnutls_srp_server_get_username
@anchor{gnutls_srp_server_get_username}
@deftypefun {const char *} {gnutls_srp_server_get_username} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the username of the peer. This should only be
called in case of SRP authentication and in case of a server.
Returns NULL in case of an error.
@end deftypefun

@subheading gnutls_srp_verifier
@anchor{gnutls_srp_verifier}
@deftypefun {int} {gnutls_srp_verifier} (const char * @var{username}, const char * @var{password}, const gnutls_datum_t * @var{salt}, const gnutls_datum_t * @var{generator}, const gnutls_datum_t * @var{prime}, gnutls_datum_t * @var{res})
@var{username}: is the user's name

@var{password}: is the user's password

@var{salt}: should be some randomly generated bytes

@var{generator}: is the generator of the group

@var{prime}: is the group's prime

@var{res}: where the verifier will be stored.

This function will create an SRP verifier, as specified in RFC2945.
The @code{prime} and @code{generator} should be one of the static parameters defined
in gnutls/extra.h or may be generated using the GCRYPT functions
@code{gcry_prime_generate()} and @code{gcry_prime_group_generator()}.
The verifier will be allocated with @code{malloc} and will be stored in @code{res} using 
binary format.
@end deftypefun

@subheading gnutls_srp_base64_encode
@anchor{gnutls_srp_base64_encode}
@deftypefun {int} {gnutls_srp_base64_encode} (const gnutls_datum_t * @var{data}, char * @var{result}, size_t * @var{result_size})
@var{data}: contain the raw data

@var{result}: the place where base64 data will be copied

@var{result_size}: holds the size of the result

This function will convert the given data to printable data, using the base64 
encoding, as used in the libsrp. This is the encoding used in SRP password files.
If the provided buffer is not long enough GNUTLS_E_SHORT_MEMORY_BUFFER is returned.
@end deftypefun

@subheading gnutls_srp_base64_encode_alloc
@anchor{gnutls_srp_base64_encode_alloc}
@deftypefun {int} {gnutls_srp_base64_encode_alloc} (const gnutls_datum_t * @var{data}, gnutls_datum_t * @var{result})
@var{data}: contains the raw data

@var{result}: will hold the newly allocated encoded data

This function will convert the given data to printable data, using the base64 
encoding. This is the encoding used in SRP password files. This function will
allocate the required memory to hold the encoded data.

You should use @code{gnutls_free()} to free the returned data.
@end deftypefun

@subheading gnutls_srp_base64_decode
@anchor{gnutls_srp_base64_decode}
@deftypefun {int} {gnutls_srp_base64_decode} (const gnutls_datum_t * @var{b64_data}, char * @var{result}, size_t * @var{result_size})
@var{b64_data}: contain the encoded data

@var{result}: the place where decoded data will be copied

@var{result_size}: holds the size of the result

This function will decode the given encoded data, using the base64 encoding
found in libsrp.

Note that b64_data should be null terminated.

Returns GNUTLS_E_SHORT_MEMORY_BUFFER if the buffer given is not long enough,
or 0 on success.
@end deftypefun

@subheading gnutls_srp_base64_decode_alloc
@anchor{gnutls_srp_base64_decode_alloc}
@deftypefun {int} {gnutls_srp_base64_decode_alloc} (const gnutls_datum_t * @var{b64_data}, gnutls_datum_t * @var{result})
@var{b64_data}: contains the encoded data

@var{result}: the place where decoded data lie

This function will decode the given encoded data. The decoded data
will be allocated, and stored into result.
It will decode using the base64 algorithm found in libsrp.

You should use @code{gnutls_free()} to free the returned data.
@end deftypefun

@subheading gnutls_psk_free_client_credentials
@anchor{gnutls_psk_free_client_credentials}
@deftypefun {void} {gnutls_psk_free_client_credentials} (gnutls_psk_client_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_psk_client_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it.
@end deftypefun

@subheading gnutls_psk_allocate_client_credentials
@anchor{gnutls_psk_allocate_client_credentials}
@deftypefun {int} {gnutls_psk_allocate_client_credentials} (gnutls_psk_client_credentials_t * @var{sc})
@var{sc}: is a pointer to an @code{gnutls_psk_server_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

Returns 0 on success.
@end deftypefun

@subheading gnutls_psk_set_client_credentials
@anchor{gnutls_psk_set_client_credentials}
@deftypefun {int} {gnutls_psk_set_client_credentials} (gnutls_psk_client_credentials_t @var{res}, const char * @var{username}, const gnutls_datum * @var{key}, unsigned int @var{flags})
@var{res}: is an @code{gnutls_psk_client_credentials_t} structure.

@var{username}: is the user's zero-terminated userid

@var{key}: is the user's key

This function sets the username and password, in a
gnutls_psk_client_credentials_t structure.  Those will be used in
PSK authentication. @code{username} should be an ASCII
string or UTF-8 strings prepared using the "SASLprep" profile of
"stringprep". The key can be either in raw byte format or in Hex
(not with the '0x' prefix).

Returns 0 on success.
@end deftypefun

@subheading gnutls_psk_free_server_credentials
@anchor{gnutls_psk_free_server_credentials}
@deftypefun {void} {gnutls_psk_free_server_credentials} (gnutls_psk_server_credentials_t @var{sc})
@var{sc}: is an @code{gnutls_psk_server_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it.
@end deftypefun

@subheading gnutls_psk_allocate_server_credentials
@anchor{gnutls_psk_allocate_server_credentials}
@deftypefun {int} {gnutls_psk_allocate_server_credentials} (gnutls_psk_server_credentials_t * @var{sc})
@var{sc}: is a pointer to an @code{gnutls_psk_server_credentials_t} structure.

This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

Returns 0 on success.
@end deftypefun

@subheading gnutls_psk_set_server_credentials_file
@anchor{gnutls_psk_set_server_credentials_file}
@deftypefun {int} {gnutls_psk_set_server_credentials_file} (gnutls_psk_server_credentials_t      @var{res}, const char * @var{password_file})
@var{res}: is an @code{gnutls_psk_server_credentials_t} structure.

@var{password_file}: is the PSK password file (passwd.psk)

This function sets the password file, in a gnutls_psk_server_credentials_t structure.
This password file holds usernames and keys and will be used for PSK authentication.

Returns 0 on success.
@end deftypefun

@subheading gnutls_psk_set_server_credentials_function
@anchor{gnutls_psk_set_server_credentials_function}
@deftypefun {void} {gnutls_psk_set_server_credentials_function} (gnutls_psk_server_credentials_t          @var{cred}, gnutls_psk_server_credentials_function          * @var{func})
@var{cred}: is a @code{gnutls_psk_server_credentials_t} structure.

@var{func}: is the callback function

This function can be used to set a callback to retrieve the user's PSK credentials.
The callback's function form is:
int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t* key);

@code{username} contains the actual username. 
The @code{key} must be filled in using the @code{gnutls_malloc()}. 

In case the callback returned a negative number then gnutls will
assume that the username does not exist.

The callback function will only be called once per handshake.
The callback function should return 0 on success, while
-1 indicates an error.
@end deftypefun

@subheading gnutls_psk_set_client_credentials_function
@anchor{gnutls_psk_set_client_credentials_function}
@deftypefun {void} {gnutls_psk_set_client_credentials_function} (gnutls_psk_client_credentials_t          @var{cred}, gnutls_psk_client_credentials_function          * @var{func})
@var{cred}: is a @code{gnutls_psk_server_credentials_t} structure.

@var{func}: is the callback function

This function can be used to set a callback to retrieve the username and
password for client PSK authentication.
The callback's function form is:
int (*callback)(gnutls_session_t, char** username,
gnutls_datum* key);

The @code{username} and @code{key} must be allocated using @code{gnutls_malloc()}.
@code{username} should be ASCII strings or UTF-8 strings 
prepared using the "SASLprep" profile of "stringprep".

The callback function will be called once per handshake.

The callback function should return 0 on success.
-1 indicates an error.
@end deftypefun

@subheading gnutls_psk_server_get_username
@anchor{gnutls_psk_server_get_username}
@deftypefun {const char *} {gnutls_psk_server_get_username} (gnutls_session_t @var{session})
@var{session}: is a gnutls session

This function will return the username of the peer. This should only be
called in case of PSK authentication and in case of a server.
Returns NULL in case of an error.
@end deftypefun

@subheading gnutls_hex_decode
@anchor{gnutls_hex_decode}
@deftypefun {int} {gnutls_hex_decode} (const gnutls_datum_t * @var{hex_data}, char * @var{result}, size_t * @var{result_size})
@var{hex_data}: contain the encoded data

@var{result}: the place where decoded data will be copied

@var{result_size}: holds the size of the result

This function will decode the given encoded data, using the hex encoding
used by PSK password files.

Note that hex_data should be null terminated.

Returns GNUTLS_E_SHORT_MEMORY_BUFFER if the buffer given is not long enough,
or 0 on success.
@end deftypefun

@subheading gnutls_hex_encode
@anchor{gnutls_hex_encode}
@deftypefun {int} {gnutls_hex_encode} (const gnutls_datum_t * @var{data}, char * @var{result}, size_t * @var{result_size})
@var{data}: contain the raw data

@var{result}: the place where hex data will be copied

@var{result_size}: holds the size of the result

This function will convert the given data to printable data, using the hex 
encoding, as used in the PSK password files.

Returns GNUTLS_E_SHORT_MEMORY_BUFFER if the buffer given is not long enough,
or 0 on success.
@end deftypefun

@subheading gnutls_psk_set_server_dh_params
@anchor{gnutls_psk_set_server_dh_params}
@deftypefun {void} {gnutls_psk_set_server_dh_params} (gnutls_psk_server_credentials_t @var{res}, gnutls_dh_params_t @var{dh_params})
@var{res}: is a gnutls_psk_server_credentials_t structure

@var{dh_params}: is a structure that holds diffie hellman parameters.

This function will set the diffie hellman parameters for an anonymous
server to use. These parameters will be used in Diffie Hellman with PSK
cipher suites.
@end deftypefun

@subheading gnutls_psk_set_server_params_function
@anchor{gnutls_psk_set_server_params_function}
@deftypefun {void} {gnutls_psk_set_server_params_function} (gnutls_psk_server_credentials_t @var{res}, gnutls_params_function * @var{func})
@var{res}: is a gnutls_certificate_credentials_t structure

@var{func}: is the function to be called

This function will set a callback in order for the server to get the 
diffie hellman parameters for PSK authentication. The callback should
return zero on success.
@end deftypefun

